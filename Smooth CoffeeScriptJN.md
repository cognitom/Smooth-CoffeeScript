![image](img/SmoothCoverWithSolutions.jpg)

---
#Smooth CoffeeScript 日本語版

---

E\. Hoigaard

*日本語翻訳者(順不同・敬称略)*
Daijiro Wachi
Takahiro Yoshida
Qubo Takaichi
Yayoi Kinoshita
Tsutomu Kawamura
Takashi Tsuda

*翻訳協力者*
Eruma Murahashi
Takatsugu Ishikawa
You Tanaka
Hiroyuki Endoh
Eikichi Yamaguchi
Jun Frank Amano

http://autotelicum.github.com/Smooth-CoffeeScript


##目次

-	[パート1.序章](#パート1.序章)
	-	[導入](#導入)
	-	[ソフトウェア](#ソフトウェア)
-	[パート2.言語](#パート2.言語)
	-	[導入](#導入)
	-	[ベーシックCoffeeScript](#ベーシック CoffeeScript)
	-	[関数](#関数)
	-	[データ構造](#データ構造)
	-	[エラー処理](#エラー処理)
-	[パート3.パラダイム](#パート3.パラダイム)
	-	[関数型プログラミング](#関数型プログラミング)

#<a name="パート1.序章">パート1.序章</a>

##<a name = "導入">導入</a>


CoffeeScriptは、Jeremy Ashkenasによって作られた、JavaScriptの輝かしい革命です。この本はMarijn Haverbekeの著書『雄弁なるJavaScript』(”Eloquent JavaScript”)を発展させることを試みています。JavaScriptの代わりとしてのCoffeeScriptは、その大きな変化はともかく、それ以外にも数えきれない程多くの変更が加えられたので説明する過程で加筆修正を行いました。

従って、この本で表現されている全てのものの文責は、ひとえに編集者にあります。OSSと同様の意味合いで、この本はフォークです。オリジナルの著者によって意図された素晴らしい作品を読みたければ、Marijn　Haverbekeの著書『雄弁なるJavaScript』(”Eloquent JavaScript”)を参照してください。

JavaScriptを知る必要はないですが、Smooth CoffeeScriptを読んだ後に、Simon Willisonの著書『JavaScript再入門』(“A re-introduction to JavaScript”)を読めば、デバッグのときや、JavaScriptライブラリを使用する際に役立ち得る概要が分かります。


この本で出てくるプログラムの例は、CoffeeScript環境に加えてPreludeファイルを使用します。Preludeファイルには、Underscore.jsの関数ライブラリ、CoffeekupによるHTMLのマークアップ、サーバーサイドWebSockets、QuickCheckテストライブラリが含まれます。これらのライブラリはCoffeeScriptを便利な抽象性とテストツールによって拡張して、気の散るような定型コードを排除し、目の前のタスクへの集中を助けます。

原始的な言語のとても小さな一式でプログラムを表現することは可能ですが、それはすぐに冗長になるし、エラーがでやすい傾向にあります。ここで採用されるアプローチは、まるでプログラミング言語のネイティブの一部であるかのように機能的な積み木の一式をより広く含むことです。これらのより高いレベルの構成の観点で考えることによって、より複雑な問題を、より少ない労力で処理することができます。

正確さを保証するためにテストすることが必要です。これは、特にダイナミック言語や型なし言語で再利用可能なアルゴリズムを開発する際は当てはまります。機能が導入されるやいなや、QuickCheckスタイルのテストケースが積み重なっていくことによって、ライティングテストと前提の宣言が一つの途切れないライティングソフトの一部分になることを意味しています。

CoffeeScriptは、JavaScriptが使用可能なブラウザや環境で使用可能です。下のスクリーンショットはMac OS X、Windows、iOS環境で、同じWebサーバー、クライアントアプリケーションを実行したCoffeeScriptを示しています。










以下のCoffeeScriptで書かれたプログラムのスクリーンショットは自己完結型アプリケーションの簡潔さを示しています。ここではCoffeekupでマークアップした独自のHTTP Webサーバで、HTML5のWebページが含まれています。ページには『生命の種子』(“Seed of Life”)の描画をCanvas要素で行なっています。Coffeekupは140行未満のCoffeeScriptで、フレームワークもJavaScriptも使われていない、純粋で快適なものです。

require './prelude'

webpage = kup.render -> doctype 5
html ->

head ->
meta charset: 'utf-8'
title 'My drawing | My awesome website' style '''

body {font-family: sans-serif}

header, nav, section, footer {display: block} '''

coffeescript ->
draw = (ctx, x, y) ->

circle = (ctx, x, y) ->
ctx.beginPath()
ctx.arc x, y, 100, 0, 2*Math.PI, false ctx.stroke()

ctx.strokeStyle = 'rgba(255,40,20,0.7)' circle ctx, x, y
for angle in [0...2*Math.PI] by 1/3*Math.PI

circle ctx, x+100*Math.cos(angle), y+100*Math.sin(angle)

window.onload = ->
canvas = document.getElementById 'drawCanvas' context = canvas.getContext '2d'
draw context, 300, 200

body ->
header -> h1 'Seed of Life'
canvas id: 'drawCanvas', width: 600, height: 400

http = require 'http'
server = http.createServer (req, res) ->

show "#{req.client.remoteAddress} #{req.method} #{req.url}" res.writeHead 200, 'Content-Type': 'text/html'
res.write webpage
res.end()

server.listen 3389
show 'Server running at' show server.address() 

###<a name = "ソフトウェア">ソフトウェア</a>

Smooth　CoffeeScriptはCoffeeScript言語についてですので、ツールの情報については以下のウェブサイトを参照してください。あなたをスタートさせる。。。

The CoffeeScript language (1.1.1 / MIT) from Jeremy Ashkenas
The Underscore library (1.1.0.FIX / MIT) included in CoffeeScript
The Coffeekup library (0.2.3 / MIT) from Maurice Machado
TranslatedwsWebSockets(MIT)fromJacekBecela
The qc testing library1 (2009 / BSD) from Darrin Thompson

必要なライブラリは標準的なCoffeeScriptに対応していて、src/preludeディレクトリに含まれています。UnderScore.js、websocket、CoffeekupはCoffeeScriptで書かれており、少しでもこの本読んで理解した読者には十分理解できます。doccoで作られたドキュメントはsrc/docsにあります。


開発環境を設定するには、まず最初に coffeescript.orgの手順に従います。Windowsを使用している場合、あなたは好みのブラウザをデフォルトでPrelude環境に適応させることができます。また、ブラウザが必要とするとき、WebSocketsを有効にする必要がある場合もあります。

CoffeeScriptをサポートするようにテキストエディタを設定するには、いくつかのリソースをwebで見つけることができます。cross platform Sublime Text 2 editorでTextMateを使用する例に関しては、パッケージ以下のCoffee Scriptディレクトリにハンドルしています。これを設定すると、構文の強調表示、コードスニペット、およびコード補完をに対応します。

ビルドファイルを追加すると、ボタンを押すだけでCoffeeScriptの実行を取得できます。
CoffeeScript.sublimeを構築して、OSに応じてパスを変更し、インストールファイルに名前を付けます。こんな感じに
{
"cmd": ["/Users/username/bin/coffee", "$file"], "file_regex": "^Error: In (...*?),

Parse error on line ([0-9]*):?", "selector": "source.coffee"

} 

最後に、再びご使用のプラットフォーム用に調整した端末とタイプでコマンドラインを開き、次に、対話型評価環境があなたを待っています。
cd path-to-smooth-coffeescript/src coffee -r ./prelude 

CoffeeScriptコンパイラの詳細については、 usage section をお読みください。あなたはcoffee filename.coffeeでサンプルを実行することができます。


Smooth CoffeeScriptは、2つのエディションで提供されます。ソリューションを使用する場合と使用しない場合。srcディレクトリ内にある章のソースコードファイルで完了します。すべてのファイルのコピーがsrc-no-solutions内にあり、これらのファイルは独自のソリューションを挿入することができます。

本からさらに得るには、テキストエディタを起動して、src-no-solutionsで、あなたが呼んでいる章のソースファイルを開きます。ワイド画面のディスプレイをお持ちの場合は、本を片側に、テキストエディタをもう片側に配置。サンプルを読みながらプログラムを実行することができるので、コードを試しに書いて、演習を解いてみてください。作業ファイルのコピーを作成すれば、簡単に実験を元に戻すこともできます。実験で動けない場合は(ディスプレイが大きくなくて)、srcディレクトリ内のファイルからの私のコードをコピーして、先に進む前にそれを少し研究してください。ソースファイルは、周辺のコードに合うようにコードをインデントすることを忘れずに行ってください。

両方のエディションと付属のソースファイルは次のサイトからDownloadできます。


#<a name = パート2.言語>パート2.言語</a>


##<a name = "導入">導入</a>

PCが最初に導入された頃、通常は単純なプログラミング言語や、BASICの派生言語が殆どの物に付属されていました。一昔前はプログラミング言語を覚えないとコンピューターは使えなかった。今ではその必要がない。今では、コンピュータが安価になったため、初心者ユーザーが増えマウスで物事をクリックする他、得られるようなことはなくなってきました。しかし、技術的な工夫に向かって努力を続ける私たちにとって、毎日コンピュータの使用におけるプログラミングの除去は、バリアのようなものを提示されたようなものだ。

幸いなことに、ワールドワイドウェブの発展の影響として、すべてのコンピュータにとても現代的なウェブブラウザが搭載されているため、簡単にCoffeeScriptの環境に適応できるところのJavaScriptプログラミング環境がある。技術的な詳細にユーザを煩わせないという今日の精神で、バックグラウンドはうまく隠され続けていますが、ウェブページには、プログラミングを学習するためのプラットフォームとして使用することができます。coffeescript.orgのメニューで"Try CoffeeScript "を選択したり、サンプルコードの下の"load"ボタンをクリックすることでそのような環境を試すことができます。


私は学ぶこと熱望していない人々、また彼ら自身で説明しようとしない人々をに教えることはしません。もし、私が正方形の一つの角で説明したのに、彼らが他の角で私の説明を思い出せないようなら、それを繰り返してもしようがないでしょう。

この本は、CoffeeScript の説明のほかにプログラミングの基本原則についても紹介するとします。プログラミングは、結局のところ、難しいです。基本的なルールは、ほとんどの場合、単純明快です。しかしプログラムは、これらの基本的なルールの上に構築しながら、独自のルールを導入したり、自分なりの工夫を行う場合は十分複雑になる傾向があります。
このため、プログラミングはほとんどの場合単純ですが、一方で予測可能です。この分野の建国の父的なドナルド・クヌース、曰く、「芸術」です。

単に受動的な読書を行うよりも、この本から何かを取得しましょう。鋭くあろうとしてください、演習を解決するための努力をしてください、あなたが前に出てきた内容を理解し合理的に確信している時のみ継続してください。

コンピュータプログラマーは、その人が担当する宇宙の唯一の生みの親です。事実上無制限の複雑さの世界は、コンピュータプログラムという形で形成することができます。ジョセフ・ワイゼンバウムの作った、人工知能のプログラムは多くの事が含まれています。

プログラムとは、多くのことです。それはプログラマが入力したテキストの一部であり、それはコンピュータが行うべきことを行えるように指示する力であり、それはコンピュータのメモリ内のデータであり、それは同じメモリ上で実行されるアクションを制御するものです。私たちが慣れ親しんだものにプログラムをなぞらえる比喩は失敗しがちだが、表面的に適してる比喩は機械だ。機械式時計の歯車は、巧みに噛みあって収まっている。そして、時計職人が優れていれば、それは正確に何年もの時を刻むことができます。プログラムの要素は、同様の方法で巧みに噛みあって収まっている。プログラマが、それらが何をしているか知っていれば、プログラムがクラッシュすることなく実行されます。

コンピュータはこれらの無形のパーツのホストとして動作するように構築されたマシンです。コンピュータ自身はまぬけで容易なことしか行うことができません。コンピュータがとても役立つ理由は、それの動作が信じられないほど速いからです。プログラムは、工夫によってシンプルなアクションを繋ぎ、とても複雑なことを行うことができます。

私たちの中のいくらかにとって、プログラムを書くことは魅力的なゲームです。プログラムは思考の建造物です。それは私たちのタイピングする手の下で無重量のものを建造します。もし夢中になれば、建造物のサイズと複雑さはコントロールできないほど成長します。誰が作ったかわからなります？　これがプログラミングでよくある問題です。今日のソフトウェアは、クラッシュし、失敗し、台無しになる傾向があるのには理由があるわけです。

プログラムが動作した時、それは美しいです。プログラミングの技術とは、制御の複雑さのスキルです。素晴らしいプログラムは抑制され、その複雑なことを簡単に行うこと。


今日、多くのプログラマーは、この複雑さは小さくて正しいプログラムでできた中身を考慮しなくても良いパッケージでのみ、ベストな管理をされると信じています。

高級言語はなんてムカツクんだろう？それを何か回りくどくなく予測ができる、自然で美しいプログラムに則ったものへ交換してみたてどうですか。そのプログラミングテクニックの全容は、巨大で、多様が魅力的で、静かに大きく人跡未踏です。

それは間違いなく落とし穴と罠まみれに散らかっており、経験不足のプログラマーをあらゆる種類の恐ろしいミスに引きつけるが、あなたの知性を用いて注意喚起をしつづけるべきだ。学ぶあなたは、常にチャレンジャーであり、新しい領域への探検家です。探検し続けることを止めたプログラマーは、着実に活気がなくなり、喜びを忘れ、プログラムを失う。(そして、マネージャーとなる。)

関心があるまで、プログラムがハッキリと基準に則ってるかどうか補正する。効率、明瞭さ、そして容量はやはり重要ですが、異なった判断の事象同士がどのように均衡を保つか、その判断とは他のプログラマーが作った？親指のルール(慣用句？)は有用ですが、それ自身が壊れることは恐れられてはいません。


まず最初に、コンピューティングの誕生した時、プログラミング言語はありませんでした。プログラムは以下みたいな感じでした。

00110001 00000000 00000000 00110011 00000001 00000010 00100010 00000010 00001000 01000001 00000001 00000001 01100010 00000000 00000000

00110001 00000001 00000001 01010001 00001011 00000010 01000011 00000001 00000000 00 

上のプログラムは、1から10までを足し、そして結果を出力します。これは、とても単純な種類のコンピュータで走らせることができました。初期のコンピュータにおけるプログラムにおいて大切だったこととは、大きなスイッチを右に配置するということや、むき出しのカードボードに穴を開け、それらをコンピュータに与えるということでした。これが退屈だったということや、エラーのでやすい傾向がある手段だということがイメージできます。シンプルなプログラムを書くということは、より多くの器用さや訓練を必要とする(なんて、信じられないでしょう)

当然、神秘的で少しパターン的なアレに手作業で入ること、プログラマーにディープで強力な魔法使いのような五感を与えましょう。そして、それは仕事時間を満たすのに値します。

プログラムは一行に一つの指示を含む。それはこのように英語みたいに書けます。
Store the number 0 in memory location 0
Store the number 1 in memory location 1
Store the value of memory location 1 in location 2
Subtract the number 11 from the value in location 2
If the value in memory location 2 is the number 0, continue
with instruction 9
Add the value of memory location 1 to location 0 Add the number 1 to the value of memory location 1 Continue with instruction 3
Output the value of memory location 0 

バイナリースープよりも読みやすい間、やはり幾分か面白みにかける。それは命令やロケーションの名前の代わりに、数字を使用するのに役立つでしょう。
Set 'total' to 0
Set 'count' to 1
[loop]
Set 'compare' to 'count'
Subtract 11 from 'compare'
If 'compare' is zero, continue at [end] Add 'count' to 'total'

Add 1 to 'count' Continue at [loop] [end]
Output 'total'

この時点では、プログラムの動作確認をするのに難しいことはありません。
最初の二行は、2つのメモリロケーションにそれぞれ初期値を与え、totalはプログラムの結果を構築するために使用され、countは今見てる数を追跡できます。compareを使用してる行は、おそらく最も奇妙なものです。どのようなプログラムが何をしたいの、いつ停止するかを決定するのにcountが11と等しいかどうかをチェックします。マシンは非常に単純なので、数が0であるかをテストして、それに基づいてのみジャンプするかを決定する。なので、countの値を計算するためにラベルされたメモリロケーションは、compareで使用で、それに基づいて決定を行います。次の二行はカウントの値を結果に与え、プログラムで常に増加量countは決める、それがまだ11じゃないかを。これはCoffeeScriptで書かれた同じプログラムです。
total = 0
count = 1
while count <= 10

total += count

count += 1 show total 

これは私たちに改善を与えました。最も重要なのは、これからはもう、あの頃の私たちが望んだ再帰呼び出しを指定する必要はないということだ。魔法の言葉、”while”がその面倒を見てくれる。count<=10、つまりcountが10以下という条件が真である間、インデントされた中の実行を繰り返す。どうやら、もはや一時的な値を作り、それを0と比較することは必要ありません。これは小さくて愚かな詳細でした、プログラミング言語の力は私たちに小さな愚かな詳細の面倒をみてくれます。

どうやら、またCoffeescriptによって短く表現されました。
total = 0
total += count for count in [1..10] show total 

forとinという単語は1~10という数字の範囲を通過し、その間countに数字をあてがいます。countに入ったそれぞれの値はtotalに加えます。

最後に、便利で効果的なsumを用いると、数字を加算していくことができるみたいです。これは数学記号のΣ10, n=1 n:に似ています。

show sum [1..10]

他の可能性はデータの型を付属する関数を持つことです。以下の場合のsumでは配列を追加して、配列の中の要素の合計を与えます。

show [1..10].sum()

この話の教訓は、上記のように同じプログラムを長くも短くも読み難くも読み易くも表現できる、ということです。プログラムの最初のバージョンは非常に不明瞭でしたが、一方で最後の方ではほとんど英語のように明瞭です。show the sum of numbers from 1 to 10.みたいにね。(後に出てくる章で、sumのようなものを作る方法が出てきます。)

多くの抽象的な方法を提供することにより、良いプログラミング言語はプログラマーを助けます。それは退屈な細部を隠し、便利なwhileのよう積み木を与え、プログラマーがsumのような建築物を加えることを許可します。


JavaScriptは、今のところ、巧妙なものから悲惨なものまで全てのWorld Wide Webにあるページで最も使われている言語です。JavaScriptはアプリやOSでのスクリプトの記述でも使われています。特に、ウェブアプリの一部の機能のようなサーバーサイドJavaScriptはJavaScriptで書かれています。なのでひとつの言語だけでアプリケーションを全て表現することができます。CoffeeScriptは標準的なJavaScriptコードを生成し、結果、標準的なJavaScriptが許可されている環境で使われる。これは、ブラウザの一部とサーバーの一部、双方をCoffeeScriptで書けることを意味する。

CoffeeScriptは新しい言語なので、まだ一般的なアプリ開発において人気になるかはわからないが、もしあなたがプログラミングに興味がわいたならば、CoffeeScriptは間違いなく学ぶのに有用な言語です。あなたがウェブプログラミングをすることにならないとしても、この本の僭越なプログラムは常にあなたと共にあり、あなたを訪れ、他の言語であなたが書いたプログラムに影響を与えます。

JavaScriptは極めてひどいと言われるでしょう。その多くは事実です。初めて何かをJavascriptで書いたとき、私はすぐにこの言語を見下しました。ほとんど全てタイプしていたが、これは私の意味する完全に異なった解釈でした。私が手がかりを持っていなかった多くのすべきことがありましたが、以下もまた核心です。JavaScriptはそれが許す限り途方もなく自由です。この設計の裏側のアイデアは初心者にとってJavaScriptでのプログラミングをより簡単にしただろう。実際、システムはプログラムの問題の箇所を示してくれないので、多くの場合それを探すことは困難です。

しかし、その言語(CoffeeScript)の柔軟性はそれを可能にします。より厳格な言語では不可能な多くの技術のためのスペースを残し、幾つかのJavaScriptの欠点を克服するために使用することができます。適切にそれを学び、そしてしばらく作業をした後、私は本当にこの言語が好きなのだと学びました。CoffeeScriptは不明確で扱いにくいJavaScriptの一面を修理し、その基礎に柔軟性と美しさを保ち続けます。まさに一石二鳥です。(doubleplusgood)


この本の多くの章はかなり多くのコードを含みます。私の経験では、プログラムを勉強するのにコードを読んだり書いたりすることはとても重要な要素です。これらのサンプルをざっと目を通すのではなく、注意深く読み理解をするようにしてください。最初はゆっくりと混乱しますが、すぐにコツが分かるでしょう。エキササイズでも同じことが言えます。実際に実用的なソリューションを書くまでは理解してると思わないでください。

ウェブの仕組みから、人々がウェブページに置いたJavaScriptのプログラムを見ることは可能です。幾つかのことが行われているのを学ぶのに、これはいい方法です。ほとんどのウェブプログラマーは”玄人”プログラマーではなく、JavaScriptのプログラミングをきちんと学んだことがなく興味がないと思っているので、とっても低クオリティのコードを見ることができます。見苦しい、または間違ったコードから学ぶときは、見苦しさと混乱があなたのコードに伝わるので、学んでいるときは注意してください。それとは違った他のプログラムのソースは、GithubのようなオープンソースサービスでホストされているCoffeeScriptのプロジェクトにあります。

ーーーーーーーーーーーーーーーーーーーー
Takahiro Yoshida (@yoshidatkhr)
Tsutomu Kawamura (@cognitom)
Eikichi Yamaguchi(@glasses_factory)
Keiichiro Matsumoto (@matsumos)
Keisuke Yamashita (@tinkle_popo)
Daijiro Wachi* (@watilde)

* main translator

##<a name = "ベーシック CoffeeScript">ベーシック CoffeeScript</a>

###値、変数と操作方法

コンピュータ世界はデータのみで出来ています。データでないものは存在しません。事実、すべてのデータはビットの固まりから作られ、各データはそれぞれの役割を担っています。CoffeeScriptシステムにおいて、ほとんどのデータは値というモノに分割されます。値の型は6種類あり、数値型（Numbers）、文字列型（Strings）、真  偽値（Booleans）、オブジェクト型（Objects）、関数型（Functions）、（Underfined）未定義型に分けられます。

値を作るときはその名前を呼び出すだけで良いです。めっちゃべんりです。事前に値を宣言する必要はなく、それを呼び出すだけでいいんです！フー！もちろん何もないところから作り出される訳ではありません。どの値もどこかにストックされています。もし同時にものすごくたくさんの値を使う場合、メモリを使い切るかもしれません。幸運な事に、本当に同時にその値を必要とする場合だけ問題になります。値は、しばらく使われないとすぐに数ビットを残し消されます。それらのビットは次に値を作る時に再利用されます。

---
数値型の値はご想像通り、数値です。数値型はいつも通り以下のように書かれます。

<pre>144</pre>

コンソールに144と入力してください。すると同じ値が出力されるはずです。この入力は数値型として解釈され、コンソールはこの数値を取得し、再度スクリーンに出力します。こんな練習は意味がなかったかもしれないけど、これからはもっと複雑な方法で値を作って行く事になるでしょう。コンソール上でプログラムが何を出力するのかを試すのは有用でしょう。

これはビットで表現した144です。

	01000000 01100010 00000000 00000000 00000000 00000000 00000000 00000000

上記の数値は64bitで、CoffeeScriptのnumbersは常に64bitです。これには重要な影響があります。表現できるnumbersの量を制限されてしまうことです。３桁だと0から999までしか書く事が出来ません。103=異なった1000の数値。64進数だと264の異なった数値を書く事ができます。これは大きい数で、1019以上です。

すべての10の19乗より下の整数がCoffeeScriptの数値に当てはまるわけではない。たいていの負の数値がそれに当てはまります。なので、それらの数値の象徴を格納しなくてはなりません。大きな問題は、非整数を表現しなくてはいけないことです。これをするには、11ビットは小数点に格納されます。

52ビットを残します。252以上1015以下の整数は安心してCoffeeScriptで使えます。たいていの場合、普段使っている数値は使えます。どっちが良いでしょう。私は特にビットに対して何も思わないけど、あなたは何かをするときにひどい大量のビットが必要なのですか。すべてが可能なら、大きなやりとりが快適になります。

少数はドットを使って表現します。

	9.81

非常に大きいか小さい数値の場合、たいていeを加えることで’科学的’表記法を利用できます。

	2.998e8

上の数値は2.998 ·108 = 299 800 000を表します。

52ビットに当てはまるwhole numbersの計算（だいたいintegersの事を指します）は正確であると保証されています。残念ながら、分数計算は通常できません。π (pi)のようなものは少数桁により計算できず、計算ミスになります。

>***ここからP.43までGoogle先生による翻訳です。どなたか…***

64ビットだけがそれらを格納するために利用できる精度。これは恥ずべきことですが、それだけで非常に特定のsituations7で実用的な問題を引き起こします。 IM大きな貢献の事はない、正確な値として、それを認識し、近似値として小数デジタル数字を扱うことです。

数字に関係する主なものは、算術演算です。加算や乗算などの算術演算は、2つの数値の値を取るとそこから新しい番号を生成する。ここでは、CoffeeScriptのように見えるものです。

100 +4 *11

+や*の記号は演算子と呼ばれます。最初の加算、および乗算第二の略です。二つの値の間に演算子を置くことは、それらの値に適用し、新しい値が生成されます。

---
例では、平均"4と100を追加、および11での結果を掛ける"か、または追加する前に実行乗算ですか。ご想像のとおり、乗算は最初に発生します。しかし、数学のように、これは括弧の中にラップすることによって変更することができます。

	（100+ 4）* 11

演算子、および除算は/で行うことができます- 減算の場合は、そこです。演算子が括弧なしで一緒に表示されるときは、それらが適用される順序は、演算子の優先順位によって決定されます。最初の例では、乗算が加算よりも優先順位が高いことを示しています。除算と乗算は常に減算と加算の前に来る。同じ優先順位を持つ複数の演算子が隣同士に（1 - 1 + 1）表示されるとき、それらは左から右へ適用されます。

これが生成する値を把握し、正しいであった​​かどうかを確認するためにそれを実行しようと...

	115* 4 - 4 +2分の88

優先順位のこれらのルールは、あなたが心配すべきものではありません。疑問がある場合は、単に括弧を追加します。

おそらくあなたにはあまり馴染みが1つ以上の算術演算子があります。 ％記号はモジュロ演算を表すために使用されます。 xをyで割った剰余314％100が14の例ではYでXを割った余りである、10％3は1で、144％12は0です。モジュロ乗算と除算と同じ優先順位を持ちます。
___

次のデータ型は文字列です。その使用は、数字と、その名前から明らかなようにではありませんが、それはまた非常に基本的な役割を果たす。文字列はテキストを表すために使用されている、名前は、おそらくそれは文字の集合をGETHERする文字列という事実に由来する。文字列は、引用符でその内容を囲むことによって、書かれています：

	'Patch my boat with chewing gum.'

ほとんど何でも引用符の間に置くことができる、とCoffeeScriptはそれのうち文字列値を行います。しかし、いくつかの文字はトリッキーです。あなたが引用符で囲んで引用符を置くことが困難であることか想像することができます。

	'The programmer pondered: "0x2b or not 0x2b"'

CoffeeScriptは、文字列の引用符の1種類のみがある場合に便利かもしれません両方の単一引用符と二重引用符で囲まれた文字列を、実装しています。

	"Aha! It's 43 if I'm not a bit off"

二重引用符で囲まれた文字列は値が、＃{と}の間にCoffeeScriptコードの小さな断片を補間含めることができます。コードが評価され、文字列に挿入されます。

	"2 + 2 gives #{2 + 2}"

改行は、Enterキーを押すとあなたが得るものは、文字列の正規形で引用符の間に置くことはできません。文字列は、過度に長いの行が、改行が出力に示されていないを避けるために複数行プログラムにまたがることができます。

	'Imagine if this was a very long line of text' 

	'''Firs then comes B'''

三重二重引用符で囲まれたバリアントが値を補間することができます。

それでも文字列の特殊文字を持つことができるように、次のトリックが使われます。たびにバックスラッシュ（'\'）引用符で囲まれたテキストの中に発見され、それは文字の後にそれが特別な意味を持っていることを示します。バックスラッシュが前置される引用符は文字列を終了するが、それの一部にはなりません。 'n'の文字がバックスラッシュの後に発生すると、それは改行として解釈されます。同様に、バックスラッシュの後に't'はタブ文字を意味します。

	'This is the first line\nAnd this is the second'

あなただけのバックスラッシュに文字列にバックスラッシュではなく、特別なコードをしたいコースの状況があります。二つのバックスラッシュは、お互いに従えば、彼らはお互いに右潰されて、1つのみが結果の文字列の値のままになります。

	'A newline character is written like \"\\n\".'

文字列は、分割乗算、または減算することができます。 +演算子は、それらを使用することができます。それは追加するが、それ一緒に連結し、その接着つの文字列はありません。

	'con' + 'cat' + 'e' + 'nate'


そこに文字列を操作するためのより多くの方法がありますが、これらは、後で説明します。

すべての演算子が記号であるではない、いくつかの単語として書き込まれます。たとえば、あなたがそれを与える値の型を指定する文字列値を生成するtypeof演算子、。

	typeof 4.5

我々が見た他​​の演算子はすべて二つの値で動作、typeof演算は1つだけを取ります。いずれかの処置を講ずるものが単項演算子と呼ばれる中に2つの値を使用する演算子は、二項演算子と呼ばれます。マイナス演算子は両方のバイナリと単項operator8として使用することができます。

	-(10 - 2)

その後、ブール型の値があります。 trueとfalse：これらの二つがあります。 CoffeeScriptは、彼らのためにいくつかの別名があります。trueは、yesまたは上のように書くことができます。なしまたはオフなどの偽。これらの選択肢はいくつかのケースで読み込むためのプログラムが容易になります。ここに真の値を生成する一つの方法は、次のとおりです。

	3>2

3 <2とfalseは、このように製造することができる

私はあなたの前に>と<兆候を見ている願っています。彼らは、それぞれ、意味する'より大きい'と'はより小さい"。彼らは二項演算子であり、そしてそれらを適用した結果は、彼らがこのケースに保持するかどうかを示すブール値です。あなたは何かが区間内にあるかどうかをテストするためにチェーンの比較することができます。これらの比較はそれぞれ真と偽与える。

	100 < 115 < 200 100 < 315 < 200

文字列は、同じ方法で比較することができます。

	'Aardvark' < 'Zoroaster'

文字列が順序付けされている方法は、多かれ少なかれアルファベットです。多かれ少なかれ... ）大文字は常に小文字のものよりも"小さい"ですので、'Z'<'trueになり、アルファベット以外の文字('!','@'なども順序に含まれています。比較が行われている実際の方法は、Unicode標準に基づいています。この規格は1つがこれまでギリシャ語、アラビア語、日本語、タミル語などから文字を含めて、必要となるほぼすべての文字に番号を割り当てます。そのような番号を持つことは、コンピュータ内部の文字列を格納するための実用的です - あなたは、数値のリストとして表すことができます。文字列を比較するとき、CoffeeScriptは、ちょうど左から右へ、文字列内の文字の数字を比較します。
	
他の同様の演算子は> =（'より大きいか等しい"）、<=（'より小さいか等しい"）、==（"等しいです"）であり、および！=（'に等しいではない" ）。に等しくもない限りに等しいとしないテキストで記述できま​​す。

	'Itchy' isnt 'Scratchy'

ブール値自体に適用できるいくつかの便利な操作もあります。と、または、ではなく：CoffeeScriptは、3つの論理演算子をサポートしています。これらは真偽値に関する"理由"に使用することができます。
論理と演算子も＆＆のように記述することができます。それは二項演算子であり、そしてそれに与えられた値の両方に該当する場合、その結果は、唯一の真です。

	true and false

論理またはエイリアスを持つ| |それに与えられた値のいずれかに該当する場合、真です：trueまたはfalse

、感嘆符のように記述することができるではない！、それは、それに与えられた値を反転する単項演算子です！真偽偽、およびではない真です。

**演習1**

	((4 >= 6) || ('grass' != 'green')) && 
	!(((12 * 2) == 144) && true)
	これは本当ですか？読みやすくするために、そこに不必要な括弧がたくさんあり​​ます。こ	のシンプルなバージョンでは、同じことを意味します。
	(4 >= 6 or 'grass' isnt 'green') and 
	not(12 * 2 is 144 and true)

￼￼￼￼**ソリューション**

	はい、それは本当です。このようなステップバイステップでそれを減らすことができます。

	私は"草"が！='グリーン'がtrueであることに気づいた願っています。草は緑かもしれないが、それは緑に等しいではありません。

	(false or true) and not(false and true) true and not false true

括弧が必要な場合には、必ずしも明白ではありません。実際には、一つは通常、比較演算子（>、==、エトセトラ）、そして残りの後、我々はこれまで見てきた演算子のことを知ることでやっていける、または最も低い優先順位を持って、次に来るとができます。これは、単純なケースでは、できるだけ少数の括弧が必要か、そのような方法で選択されています。

---
あなたが電卓を使用するのと同じようにすべての例では、これまでの言語を使用している。いくつかの値を確認し、新しい値を取得するためにそれらに演算子を適用する。このような値を作成すると、すべてのCoffeeScriptプログラムの重要な部分ですが、それは一部にすぎません。値を生成するコードの断片は表現と呼ばれています。 （このような22または"精神分析"など）に直接書き込まれるすべての値は式です。括弧の間の式も式です。と二つの式、または1つに適用される単項演算子に適用される二項演算子は、また式です。

時間が熟したときは明らかにされる建物の表現、さらにいくつかの方法があります。

の式より大きいユニットが存在する。それは、ステートメントと呼ばれています。プログラムは、文のリストとして構築されています。文が多くの行に渡ってできるもののほとんどのステートメントは、改行で終了。 （;）の文もセミコロンで終了することができます。あなたが同じ行に複数のステートメントを配置する場合CoffeeScriptセミコロンで主に使用されます。文の最も単純な種類は、それの後のセミコロンを持つ式なのです。これはプログラムです。
	1; !false

それは無駄なプログラムです。式は、単に値を生成するコンテンツになることができますが、それは何らかの形で世界を変える場合、ステートメントは何かにのぼります。それは、画面に何かを印刷することができる - それが世界を変えるとしてカウントする - またはそれはそれの後に来る文に影響を与える方法で、プログラムの内部状態を変更することができます。これらの変更は、"副作用"と呼ばれています。例の文では、上記の値だけ1と真を生成し、すぐにビットbucket9にそれらを投げる。これは全く世界には印象を残していない、と副作用ではありません。

プログラムはどのように内部状態を保持していますか？それはどのように物事を覚えているのでしょうか？私たちは、古い値から新しい値を生成する方法を見てきましたが、これは古い値を変更しない、と新しい値はすぐに使用することにしているか、それが再び消費されます。キャッチして値を保持するために、CoffeeScriptは変数と呼ばれるものが用意されています。

	caught = 5 * 5

---

変数は、常に名前があり、それを保持し、値で指定することができます。上記のステートメントでは、変数捕捉と呼ばれるを作成し、5を5で乗じて生成される数値のホールドをつかむためにそれを使用しています。

上記のプログラムを実行した後、コンソールにキャッチワードを入力すると、それはあなたのために値25を取得します。変数の名前は、その値を取得するために使用されます。キャッチ+ 1も動作します。変数名を式として使用することができ、より大きな式の一部にすることができます。

=演算子を持つ新しい変数名に値を割り当てると、新しい変数を作成します。変数名は、ほとんどすべての語を使用できますが、スペースが含まれていない場合があります。数字が変数名の一部にすることができます、catch22は有効な名前ですが、名前は1つで開始してはならない。彼らは文字であるかのように文字'$'と'_'が名に使用できるので、$ _ $は正しい変数名です。

ときに、それはそれは永遠にその値に結び付けられている値で変数の点を意味するものではありません。いつでも、=演算子は、その現在の値からそれらを離れてヤンクし、新しいものにそれらを指すように既存の変数を使用することができます。

	caught = 4 * 4

---
あなたは触手のような変数ではなく、箱を想像してみてください。彼らは値が含まれていない、彼らはそれらを把握する - 二つの変数が同じ値を参照することができます。プログラムがまだ保留されていることを唯一の値は、それによってアクセスすることができます。あなたが何かを覚えておく必要があるときは、触手はそれを保持するために、または新しい値に、既存の触手の一つを再アタッチ成長：ルイージはまだあなたを負っていることはドルの量を覚えてするには、何ができる...

	luigiDebt = 140

その後、ルイージは何かを支払うたびに、この金額は、することができますデクリメント変数に新しい番号を与えることでmented：

	luigiDebt = luigiDebt - 35

所定の時間に存在する変数とその値の集合は、環境と呼ばれています。プログラムが起動すると、この環境は、空ではありません。それは、常に標準的な変数の数が含まれています。あなたは、CoffeeScriptプログラムを実行したり、その後環境がグローバルと呼ばれるコーヒーの- r。/前奏曲とインタラクティブな環境を実行するためにコーヒーを使用したとき。あなたは次のように入力して、それを表示することができます：これ。 →| /'タブ"。ブラウザがページをロードするとき、それはウィンドウと呼ばれる新しい環境を作成し、それにこれらの標準値を添付します。ブラウザが新しいページになるまで、そのページ上で作成し、プログラムによって変更された変数が生き残る。

---
標準的な環境が提供する値の多くは、型'関数'を持っている。この関数は、値に包まれたプログラムの一部です。 GENER -同盟国、プログラムのこの部分は、それを含む関数の値を使用して誘発することができる便利なものを、行います。開発環境では、変数ショーは、端末またはコマンドラインウィンドウでメッセージを表示する機能を保持しています。このように使うことができます。

	show 'Also, your hair is on fire.'

関数内のコードを実行すると、それを呼び出すか、適用することと呼ばれています。これを行うための表記法は、括弧または値のカンマ区切りのリストが後に続く関数名です。関数るの値を生成するすべての式は、それの後に括弧を置くことによって呼び出すことができます。値が渡される場合には括弧を省略することができます。文字列値は、コンソールウィンドウに表示するテキストとして、それを使用する関数、に与えられます。関数に与えられた値は、パラメータまたは引数と呼ばれます。ショーは、いずれか一方だけを必要としますが、他の関数が別の番号が必要になることがあります。

メッセージを表示すると、副作用です。関数の多くは、理由は、生成副作用が便利です。それは、それが有用であることが副作用を持っている必要がない場合、値を、生成する機能も可能です。例えば、二つの引数を取るとバック両者の最大を与える関数のMath.maxは、あります。

	show Math.max 2, 4

関数が値を生成するとき、それはそれを返すように言われています。値を生成することが常にCoffeeScriptの式であるため、関数呼び出しは、より大きな式の一部として使用することができます。

	show 100 + Math.max 7, 4 show Math.max(7, 4) + 100 show Math.max(7, 4 + 100) showMath.max 7, 4 + 100

括弧は、関数からは除外されているときには、行の最後にストレッチを挿入CoffeeScript IM - plicitlyして呼ぶ。それ上の例では最初の2行が答え107最後の二つの104を与えることを意味します。だからあなたの意図に応じてあなたが望む結果を得るために括弧を使用する必要があります。関数は、独自の関数を書くことについて説明します。

---
前の例が示すように、ショーは式の結果を表示する場合に便利です。ショーは、標準のCoffeeScript関数ではないブラウザでは、あなたのためにそれを提供しない、それがスムーズコーヒースクリプトのプレリュードで利用できるようになります。 Webブラウザで作業しているときは、別の環境があり、代わりにメッセージを含むダイアログをポップアップするように警告することができます。

我々は、CoffeeScript環境で継続されます。ショーは、値の型についての詳細な情報を与えることができる、それがプログラムで見えるような方法を、その引数を表示しようとします。インタラクティブコンソールでは、コーヒー- rで開始/前奏曲は、あなたが環境を探索することができます。

どのような出力が意味することは、今はそれほど重要ではありません。ショーはあなたに何かが予想していたように動作しない場合は、後で便利なことができるプログラムのこと、についての詳細を与えることができるツールです。

ブラウザにより提供される環境では、ウィンドウがポップアップするためのいくつかのより多くの機能が含まれています。あなたは、ユーザーが[OK]を求める/確定を使って質問をキャンセルすることができます。これは、ブール値を押下"OK"であれば真、そして彼を押すが、"キャンセル"場合はfalseを返します。プレリュードでは、ユーザーが質問にyesまたはnoを聞かれていない同様の確認機能を備えています。

CoffeeScript環境がサーバとして動作するように最適化されているので、返信にユーザーのために待機しません。その代わりに、フォローINGコードを実行する関数呼び出しを続けています。最終的にユーザーが質問に応答したときに、

	show process
	show console
	show _
	show show

どのような出力手段と、今はそれほど重要ではありません。ショーができるツールです
あなたの後に便利なことができますあなたのプログラムで物事の詳細を与える、
何かがあなたが予想していたように動作していない場合。

---
その後、引数として渡された関数がその答えと呼ばれています。コー​​ドのこの部分は関数で説明する魔法のビットを伴います。それは、この使用のためのより複雑ですが、我々は後の章では、多くのユーザーとWebアプリケーションのための完

	confirm 'Shall we, then?', (answer) -> show answer

プロンプトが"オープン"質問をするために使用することができます。最初の引数は質問で、2番目はユーザーの起動に使用されるテキストです。テキスト行がウィンドウに入力することができ、関数は予定 - ブラウザで - 文字列として返します。として確定したプレリュードは、答えを受け取る番目の引数をとる同様の機能を、提供しています。

	prompt 'Tell us everything you know.', '...',	  (answer) -> show 'So you know: ' + answer

---
環境で新たな価値をほとんどすべての変数を与える事が可能です。これは便利なだけでなく、危険なことができます。あなたが値8を表示与えれば、あなたはもはや物事を表示することができなくなります。あなたがファイルからプログラムを実行するが、インタラクティブな環境で十分に相互作用の確認およびプロンプトの作品のようないくつかの関数。幸いにも、CTRL - Cでプログラムを停止し、中断したところから拾うことができます。

---
ワンラインプログラムは、非常に面白いものではありません。あなたがプログラムに複数のステートメントを配置すると、文は、予想通り、上から下へ、一つずつ実行されます。

	prompt 'Pick a number', '', (answer) ->	  theNumber = Number answer	  show 'Your number is the square root of ' +		(theNumber * theNumber)

機能番号は、プロンプトから答えがストリング値であるため、この場合に必要とされる数値、値を変換します。これらの型に値を変換する文字列やブールと呼ばれる同様の機能があります。

---
0から12へのすべての偶数を出力するプログラムを考えてみましょう。これを記述する一つの方法は、次のとおりです。

	show 0
	show 2
	show 4
	show 6
	show 8
	show 10
	show 12

動作しますが、プログラムを書くというアイデアは、何か少ない仕事ではなく、よりにすることです。我々が1000以下のすべての偶数を必要に応じて、上記では実行不可能であろう。必要なのは、自動的にいくつかのコードを繰り返す方法です。

	currentNumber = 0	while currentNumber <= 12	  show currentNumber	  currentNumber = currentNumber + 2

はじめの章の間は、見るかもしれない。ループを作成している間の単語で始まる文。ループは、文の順序の乱れている、それはいくつかのステートメントを複数回繰り返すようにプログラムを引き起こす可能性があります。このケースでは、単語の間は、ループは、ループまたは終了するかどうかを判断するために使用されている表現が続きます。この式によって生成されるブール値がtrueである限りとして、ループ内のコードが繰り返されます。とすぐにそれが偽であるとして、プログラムはループの一番下に移動し、通常どおり継続。

T変数currentNumberは、変数がプログラムの進行状況を追跡できる方法を示しています。たびにループが繰り返される、それは2ずつインクリメントされ、各繰り返しの開始時に、それがループし続けるかどうかを決定する12番と比較されます。

while文の3番目の部分は、別のステートメントです。これは、ループ、アクションや場所を複数回行なう必要のある操作のボディです。で、歯牙状の構造は、ブロックにグループステートメントに使用されます。ブロック外の世界に、ブロックは、単一の文として数えます。例では、これはループ内で表示する呼び出しと、更新がcurrentNumberという文の両方を含むように使用されます。

我々は数字を印刷するには持っていなかった場合、プログラムはあったかもしれない。

	counter = 0	while counter <= 12 then counter = counter + 2

ここで、カウンタ=カウンタ+ 2は、ループの本体を形成するステートメントです。そしてキーワードは体内からブール値を分離し、その両方が同じ行にすることができます。

￼￼￼	演習2

	210の値（2 10乗まで）を計算して表示するプログラムを書くことはこれまでに示した手法を使用してください。あなたは明らかに、わずか2 * 2 *を記述するような安価なトリックを使用するために許可されていない、です...

	この問題がある場合は、偶数番号の例の面でそれを見てみてください。プログラムはアクションを何度も一定量を実行する必要があります。 whileループでカウンタ変数は、そのために使用することができます。代わりにカウンターを印刷するので、プログラムが2で何かを掛ける必要があります。この何かは、結果値が構築されている、別の変数でなければなりません。

	あなたは非常にこれはまだどのように働くか見ても心配しないでください。あなたが完全にこの章で取り上げるすべてのテクニックを理解している場合でも、それは特定の問題に適用することは困難です。コー​​ドを読み書きすることはこのための感覚を開発するのに役立つので、解決策を検討し、次の練習をしてみてください。

￼￼￼￼	ソリューション

	result = 1
	counter = 0
	while counter < 10
	  result = result * 2
	  counter = counter + 1
	show result

	カウンターがまた1から開始して= 10 <をチェックすることができる、しかし、後で明らかになる理由のため、それは0からカウントするために慣れるには良いアイデアです。

	明らかに、独自のソリューションは、私とまったく同じである必要はありません。彼らは動作するはずです。そして彼らは非常に異なっている場合、あなたがまた私の解決策を理解してください。



演習3

	多少変更して、前の練習への解決策は、三角形を描画させることができます。そして私は"は三角形を描く"と言うとき、私は"はほぼ三角形のようないくつかのテキストをプリントアウトする際に目を細め"という意味。
	
	10行をプリントアウトする。最初の行に1つの'＃'文字がある。第二上の2つがあります。というように。

	どのようにしてそれでX'＃'文字で文字列を取得するのですか？ループ内のループ - 一つの方法はそれを、それが"内側のループ"で必要になるたびに構築することです。簡単な方法は、ループの前の反復が使用されている文字列を再利用、およびそれの1文字を追加することです。

￼￼￼￼ソリューション

	line = ''
	counter = 0
	while counter < 10
	  line = line + '#'
	  show line
	  counter = counter + 1

あなたは、私はいくつかのステートメントの前に置くスペースが気づいているだろう。これらは必須です：インデントのレベルは、行が属するブロックを決定します。ブロック内のインデントの役割は、読者へのコードの明確な構造を作ることです。新しいブロックが他のブロックの内部で開かれる可能性があるため、それは一つのブロックが終了するとそれらがインデントされていない場合は、別のが始まる場所を確認するのは困難になることができます。の行がインデントされている場合、プログラムの視覚的な形状は、その内部のブロックの形状に対応しています。私は開いているすべてのブロックの2つのスペースを使用したいのですが、味は異なります。行が長くなりすぎる場合は、その行の最後に2つの単語または場所\の間に分割し、次に続けることができます。

---
我々はこれまですべて同じパターンを示して見ている間の使用しています。最初に、"カウンター"変数が作成されます。この変数は、ループの進行状況を追跡します。

自身がチェックが含まれている間、通常のカウンタはまだいくつかの境界に達したかどうかを確認する。その後、ループ本体の最後に、カウンタが更新されます。

ループの多くはこのパターンに分類されます。このため、CoffeeScript、および類似の言語については、また少し短くし、より包括的なフォームを提供します。

	for number in [0..12] by 2 then show number

このプログラムは、以前の偶数番号 - 印刷元に十分とまったく同じです。唯一の変更点は、ループの"状態"に関連するすべての文が一行になっていることになります。角括弧内の数字は、範囲[4 .. 7]、数字の最初の番号から開始し、最後に1つずつ上がっていくの一覧です。 2つのドットを持つ範囲は、3つのドット[4 ... 7]最後の数が除外されている（4,5,6）とリスト（4,5,6,7）の最後の数字が含まれています。各ステップの量は、キーワードを変更することができます。ので[2 .. 6] 2によっては、リスト（2,4,6）を与える。最初の数字が最も大きい、またはであれば範囲も減らされるが、負の数または浮動小数点数を含むことができる。

理解するための番号は、ループを介して各ターンの間に範囲から後続の各値を取る。数の値は、それが計算にまたはここにショーの数のように使用することができるループの本体で使用できるようになります。ほとんどの場合、これはしばらくの間の建設より短く、明確です。

理解は、他の形態を取ることができるため。一つは、ループの本体はfor文の前に与えることができるということです。

前の例では'＃'で始まる行はあなたに少し不審に見えたかもしれない。それは、プログラム内の余分なテキストを含めることがしばしば有用です。このための最も一般的な使用方法はプログラムする人間で言語のいくつかの説明を追加しています。

	# For with indented body
	for number in [0..12] by 2
	  show number
	
	# For with prepended body
	show number for number in [0..12] by 2

---

	# The variable counter, which is about to be defined,
	# is going to start with a value of 0, which is zero.
	counter = 0
	# Now, we are going to loop, hold on to your hat.
	while counter < 100 # counter is less than one hundred
	  ###
	  Every time we loop, we INCREMENT the value of counter
	  Seriously, we just add one to it.
	  ###
	  counter++
	# And then, we are done.

This kind of text is called a comment. The rules are like this: ‘#’ starts a comment, which goes on until the end of the line. ‘###’ starts another kind of comment that goes on until a ‘###’ is found so it can stretch over multiple lines.

As you can see, even the simplest programs can be made to look big, ugly, and complicated by simply adding a lot of comments to them.

---

テキストのこの種のコメントと呼ばれています。ルールは次のようになります：'＃'は、行の終わりまで続くコメントを開始します。 '###'は、それが複数の行に伸ばすことができるように'###'が見つかるまで、上に行くコメントの別の種類を開始します。

ご覧のように、ごく単純なプログラムは、大きな醜い、と単純にそれらに多くのコメントを追加することによって、複雑に見えるために行うことができます。

◦•◦

私はいくつかの変数名にいくつかかなり奇妙な時価総額を使用している。これらの名前にスペースを持つことができないので - コンピュータは2つの別々の変数としてそれらを読んでいました - いくつかの単語で構成されている名前については、選択肢は以下の多かれ少なかれ制限されています。

	fuzzylittleturtle		FuzzyLittleTurtle
	fuzzy_little_turtle 	fuzzyLittleTurtle

最初は読みにくいです。それは型に少し痛いですが個人的に、私は、アンダースコアのものを好き。しかし、CoffeeScriptは、JavaScriptから進化したので、ほとんどのCoffeeScriptプログラマは最後のもので、JavaScriptの規則に従います。その標準のJavaScript関数で使用されるもの。それはそのようなささいなことに慣れるのは難しいではない、私は観客に従って、最初の後の各単語の最初の文字を大文字になりますので。

そのような番号の関数として、いくつかのケースでは、変数の最初の文字も大文字になります。これはコンストラクタとしてこの関数を記念して行われました。どのようなコンストラクタがあると、オブジェクト指向で明らかになります。今のところ、重要なことは、一貫性のこの明らかな不足に悩まされないためにです。

そのような中などの特別な意味を持つ名前、、と変数名として使用されていない可能性がありますのためのことに注意してください。これらは、キーワードと呼ばれます。 JavaベースのスクリプトとCoffeeScriptの将来のバージョンで"使用するために予約"されている単語の数もあります。一部の環境では、それらを許可していないものの、これらはまた、公式に、変数名として使用することを許可されていません。予約語の完全なリストは、やや長めです。

今のところこれらを暗記する心配が、これは何かが期待通りに動作しない問題になるかもしれないことを覚えてはいけません。私の経験では、CHAR（1文字の文字列を格納する）とクラスが誤って使用するのが最も一般的な名前です。


**￼￼￼演習4**

	代わりにしばらくの間使用する前の2つの演習のソリューションを書き換える。

￼￼￼￼**ソリューション**

	result = 1
	for counter in [0...10]
	  result = result * 2
	  show result

	排他的な範囲とその使用方法に注意してください - で必要とされるコーヒー
	スクリプト - ループ内のステートメントは、make2のスペースでインデントされてい
	それは上の行に "属して"それは明らかです。

	line = ''	for counter in [0...10]	  line = line + '#'	  show line

プログラムは、多くの場合、その前の値に基づいて値を持つ変数を"更新"する必要があります。例えばカウンタ用=カウンタ+ 1。カウンタ+ = 1：CoffeeScriptは、このためのショートカットが用意されています。これはまた、下方にカウントする結果の値、またはカウンタ-= 1を倍増させる例の結果*= 2のために、他の多くの演算子のために動作します。カウンタ+ +とカウンター - カウンター+ = 1とカウンタ-= 1の短いバージョンです。

ループは、プログラムの制御フローに影響を与えると言われています。彼らは、ステートメントが実行される順序を変更します。多くの場合、フローの別の種類のに便利です：文をスキップする。

我々は3で、4の両方によって割り切れる0〜20のすべての数字を表示したいとします。

---
キーワードifキーワードの中からあまりにも違いはありません：それは、それが与えられた条件をチェックし、それがこの条件に基づいて後にステートメントを実行します。しかし、文が0回または1回実行されるように、一度だけこれを行います。

モジュロ（％）演算子を持つトリックは数が別の数で割り切れるかどうかをテストする簡単な方法です。その場合、モジュロを与えるものであるそれらの部門、、余りは0である。

我々は0〜20の数字のすべてを印刷したいが、4の倍数ではないものの周りに括弧学位論文を配置した場合、我々はこのようにしてください：

	for counter in [0..20]	  if counter % 4 == 0		show counter	  if counter % 4 != 0		show '(' + counter + ')'

しかし、今のプログラムは、カウンタが4の2倍で割り切れるかどうかを判断する必要があります。同じ効果は、if文の後には他の部分を付加することによって得ることができます。 else文は、ifの条件が偽のときのみ実行されます。

	for counter in [0..20]	  if counter % 4 == 0		show counter	  else		show '(' + counter + ')'

少しさらに、このような簡単な例を伸ばすために、我々は今これらの同じ番号を印刷したいが、彼らが15より大きいとき、彼らが10（ただし、15より大きい）より大きいとき、それらの後で1つ星を二つの星を追加し、ない星そうでなければ。

	for counter in [0..20]	  if counter > 15		show counter + '**'	  else if counter > 10		show counter + '*'	  else		show counter

これは一緒にif文の連鎖があることを示しています。カウンタが15よりも大きい場合は、このケースでは、プログラムは最初に見える。それがある場合は、二つの星が印刷され、他のテストはスキップされます。そうでない場合、我々はカウンターが10より大きいかどうかをチェックし続けます。カウンターも10より大きいではない場合にのみそれが最後のSHOWステートメントに到達しません。

￼￼￼**演習5**

	2 + 2の値が何であるかプロンプトを、使用して、自問するプログラムを書きなさい。答えは'4'の場合は、賞賛する何かを言うには、showを使用してください。それが'3'または'5'の場合は、"ほとんど！"と言う。他のケースでは、何か意味と言う。プロンプトで必要な魔法の少しのために30ページを参照して下さい。

￼￼￼￼**ソリューション**

	prompt 'You! What is the value of 2 + 2?', '',
	  (answer) ->
		if answer == '4'
		  show 'You must be a genius or something.'
		else if answer == '3' || answer == '5' 
		  show 'Almost!'
		else
		  show 'You are an embarrassment.'

プログラムの論理テストが複雑になることができます。条件- tions書き込みを助けるために明確にCoffeeScriptは、上のバリエーションのいくつかを提供する場合は状態- MENT：ifステートメントの本体は、条件の前に置くことができるかどうか。としない限り、のように記述することができる場合ではない。

	fun = on
	show 'The show is on!' unless fun is off

ループは、常にその終りまでの全ての道を行くことがないときは、breakキーワードが便利です。それは、その直後に続けて、現在のループの外にジャンプします。このプログラムは20を超え、7で割り切れる最初の番号を検索します。

	current = 20	loop	  if current % 7 == 0		break	  current++	show current

ループ構造は、ループの終わりをチェックする部分を持っていません。それは、真の時間と同じです。これは、今まで停止してその中にbreak文に依存していることを意味します。同プログラムはまた、単純に書かれている可能性が...

	current = 20	current++ until current % 7 == 0	show current

この場合、ループの本体は、ループテストの前に来ます。キーワードがない限り、キーワード、しかし一方ではないに変換に似てまで。ループの唯一の効果は、その目的の値に可変電流をインクリメントすることです。しかし、私は休憩を使用する例を必要なので、あまりにも最初のバージョンに注意を払う。

￼￼￼**演習6**

	その後、1から6までのラッキーナンバーを選んであなたのラッキーナンバーが表示されるまで、シミュレートされたサイコロを保つ。ロールの数をカウントします。ループと、オプションでブレークを使用してください。ダイをキャストすると、シミュレーションすることができます。

	ロール=数学。床Math.random（）* 6 + 1

	そのループが真の間と同じであり、両方が独自のアカウント上で終わっていないループをCRE -食べたにも使用できます。真の有用なトリックが、ビットばかげている間に書き込み、あなたが真の真である限りループするプログラムを尋ねる、好ましい方法は、ループを記述することですので。

**ソリューション**

	luckyNumber = 5 # Choose from 1 to 6	show "Your lucky number is #{luckyNumber}"	count = 0	loop	  show roll = Math.floor Math.random() * 6 + 1	  count++	  if roll is luckyNumber then break	show "Luck took #{count} roll(s)"show "Luck took #{count} roll(s)"

	ブレークが悪用統計を除くほぼ間違いなくよりよい別の解決策:

	luckyNumber = 3 # Choose from 1 to 6	show 'Your lucky number is ' + luckyNumber	count = 0	until roll is luckyNumber	  show roll = Math.floor Math.random() * 6 + 1	  count++	show 'You are lucky ' +	  	Math.floor(100/count) + '% of the time'

前の実習のロールへの2番目のソリューションではループを介して値を初めて設定されていない。それは次のステートメントで値が割り当てられます。この変数の値を取る場合はどうなりますか？

	show mysteryVariable
	mysteryVariable = 'nothing'

触手の面では、この変数は、薄い空気で終わる、それは把握するのは関係ありません。あなたが空の場所の値を求めるときは、未定義の名前の特別な値を得る。このような組み込み関数として興味深い値を、返していない関数も定義されていない値を返すCONSOLE.LOG。 CoffeeScriptのほとんどのものは、さらにほとんどの文を値を返す。プレリュードの関数は、与えられた値を返すことを示すので、式の中で使用することができます。

	show console.log 'I am a side effect.'

その意味は同様の値、nullは、この変数は'もあります

定義されていますが、値を"持っていません。間の意味の違い

未定義とnullは主に学術的、そして通常非常に興味深いものではありません。実用的なプログラムでは、それは何かが"価値を持っている"かどうかを確認する必要がしばしばあります。このような場合で、式の何か？使用されるかもしれない、？実存的な演算子と呼ばれています。何かがnullまたはundefinedでない限り、それはtrueを返します。また、実存的な割り当​​ての形で来る？のみのどちらかがnullまたは未定義の変数に代入されます=。

	show iam ? undefined	iam ?= 'I want to be'	show iam	iam ?= 'I am already'	show iam if iam?

---
それは別の話題に私たちをもたらします...もしあなたが、Java - Scriptのにさらされているなら、あなたはさまざまなタイプの比較は難しいことができることを知っている。

	show false == 0	show '' == 0	show '5' == 5

JavaScriptでは、すべてのこれらは真の値を与える - ないのでそれらがすべて偽であるCoffeeScriptに。異なる型を持つ値を比較する場合には、まず、互換性のある型に変換する必要があります。我々は、数などの数（'5'）== 5は真与えるとこの前のを見た。コー​​ヒースクリプトで==の挙動は、JavaScriptの===と同じです。

	show `null === undefined `	show `false === 0`	show `'' === 0`	show `'5' === 5`

これらはすべてfalseです。あなたは、バッククォートでシュール丸めによってCoffeeScriptでJavaScriptコードをJavaScriptを埋め込むことができます。あなたがCoffeeScriptを持っている時にJavaScriptを使用すると、高水準言語でアセンブリ言語を埋め込むに似ています。それはあなたがする必要がない非常にまれなものでなければなりません。

---
自動型変換が発生する原因となるいくつかの他の状況があります。あなたが文字列に文字列以外の値を入れても、それが連結される前に、値は自動的に文字列に変換されます。あなたが数値と文字列を掛ける場合、CoffeeScriptは、文字列の数を作ることを試みます。

	show 'Apollo' + 5	show null + 'ify'	show '5' * 5	show 'strawberry' * 5

最後の文は、特殊な値であるNaNを出力します。それは"ではない数"の略で、（少し矛盾して聞こえる可能性がある）型はNUMBERです。この場合、それはイチゴが数値ではないという事実を表しています。なぜ5を乗じているがNaNの値がNaNの結果のすべての算術 - 算術演算は、、例のように、依然としてNaN値を与えます。また、これは時には混乱させることができる、NaNは== NaNは値がNaNがisNaNは関数で実行できるかどうかをチェックし、偽等しい。

これらの自動変換は非常に便利ですが、彼らはまた、やや奇妙なエラーが発生しやすくなります。 +と\*の両方の算術演算子が表示されています、これらは例の完全に異なる動作にもかかわらず。私自身のコードでは、私は非文字列の多くの上で+を使用しますが、その文字列値に*やその他の数値演算子を使用しないようにポイントします。

数値を文字列に変換することは常に可能と簡単ですが、文字列を数値に変換するにも（例の最後の行のように）動作しない場合があります。私たちは、明示的にそれを明確に我々がNaNの値を得ることの危険性を実行される可能性があるということ、文字列を数値に変換する数値を使用することができます。

	show Number('5') * 5

---
我々は、ブール演算子について議論＆＆とするとき| |以前、私は、彼らがブール値を生成したと主張した。これはoversim - plificationのビットであることが判明した。あなたがブール値に適用した場合、彼らは確かに真偽値を返します。しかし、彼らは他のタイプの値にも適用することができます、その場合、彼らは彼らのいずれかの引数を返します。

何が| |本当にこれはない：それは最初にそれの左側の値が参照されます。 booleanにこの値を変換することが真生成するような場合、それはこの左の値を返し、それ以外の場合は、その右上の1つを返します。これは、引数がブール値である正しいことを行うことを自分自身のために確認してください。それはなぜそのように動作しますか？これは非常に実用的であるがわかりました。この例を考えてみます。

	prompt 'What is your name?', '', 
	  (input) ->
		show 'Well hello ' + (input || 'dear')

ユーザーを押す←􏰀/名前を与えることなく、'Enter'をする場合、変数入力は値''を開催します。 booleanに変換するときにこれは偽与えるだろう。式の入力| |"親愛なる"は、このケースでは'''変数inputの値、または他の文字列'として親愛なる読み取ることができます。それは、"フォールバック"の価値を提供する簡単な方法です。

＆＆演算子と同様に動作しますが、他の方法で回避。その左側の値がブール値に変換されたときにfalseを与える何かであるときは、その値を返し、それ以外の場合は、右側にある値を返します。

これら2つの演算子の別のプロパティは、必要に応じて、右側の式が唯一評価されるということです。真の場合、| | X、Xが何であるかに関係なく、結果はtrueにならないので、Xは評価されません、そして、それが副作用を持つ場合、それらが発生されることはありません。同じはfalse＆＆Xのために行く

	false || alert 'I am happening!' 
	true || alert 'Not me.' 


ここまでGoogle先生の翻訳

##<a name = "関数">関数</a>



プログラムでは、異なる場面で同じ処理が必要になることがあります。同じ命令文を繰り返し書くことは退屈な作業であり、またエラーの温床ともなります。こういった処理を、プログラム実行時に必要に応じて呼び出せるよう、一箇所にまとめておくことはできないでしょうか？ここで関数が役に立ちます。関数とは、プログラムがいつでも呼び出せるコードの缶詰のようなものです文字列を画面上に出力するには数行の命令文を書かなければいけません。しかしshow関数を用いれば、例えばshow 'Aleph'と書くだけでそれが実現できるのです。

いま関数を「コードの缶詰」と表現しましたが、関数の役割はこれだけではありません。純粋関数、アルゴリズム、間接参照、抽象化、意思決定、モジュール、継続、データ構造など、関数は用途に応じて様々な役割を果たすことができます。関数を上手に使いこなすスキルは、プロフェッショナルなプログラマにとっては必要不可欠です。この章では、関数の大まかな紹介を行ってゆきますこの章は、関数のイントロダクションになります。より細かな説明に関しては、関数プログラミングを参照して下さい。

まず純粋関数から説明してゆきましょう。純粋関数とは、皆さんがかつて数学の授業で学んだであろう、いわゆる数学の関数のことを指します。ある数値のコサインや絶対値などを求めるのは、引数が１個の純粋関数にあたります。加算は引数２の純粋関数です。純粋関数の重要な特徴として、同じ引数を与えた場合に必ず同じ値を返し、決して副作用を持たない、というものがあります。いくつかの引数を取り、それらの値に基づいた計算結果を返す以外に、何も余計なことは行いません。

CoffeeScriptでは、加算は演算子として存在しますが、このように関数でラッピングすることもできます（無意味に見えるかもしれません。しかしこれが実際に役立つケースを後ほど紹介します）。

add = (a, b) -> a + b
show add 2, 2 

addは関数の名前、そしてaとbが２つの引数の名前です。a+bは、関数の本体となります。「->」は、新しく関数を作るときに使います。ある変数の名前を割り当てたときに、その関数名の下にその関数が保存されます。「->」の前には、括弧で囲まれた引数リストがきます。関数は引数を取らない場合は、括弧は必要ありません。「->」の後は関数の本体です。関数本体は「->」の後の同じ行に書き切っても続けてもいいですし、インデントを設定して次以降の行に書いても構いません。関数の最後の命令文は関数の戻り値となります。また、予約語であるreturnの後に式を書けば、その式が関数の戻り値になります。 プログラムはreturn文を処理した時点で直ちに関数から抜け出し、その関数の呼び出し元のコードに、計算結果である戻り値を渡すことになります。式の無いreturn文の場合、関数はundefinedを返します。関数本体には、もちろん複数の命令文を記述することができます。ではここで、自然数のべき乗を求める関数を見てみましょう。

power = (base, exponent) ->

  result = 1

  for count in [0...exponent]

    result *= base

  result

show power 2, 10

３２ページの練習問題を解かれた方には、このべき乗の計算方法には見覚えがあるはずです。変数（計算結果）を作り、その値を更新することは副作用と言えます。しかし私はつい先ほど、純粋関数には副作用がないと言ったばかりですよね？実は関数内で生成された変数は、その関数の中でのみ有効なのです。おかげでプログラマーは、「プログラム内のあらゆる変数にそれぞれ異なった名前をつけなければいけない」などという羽目に陥らずに済むのです。resultはpower関数の中でのみ存在する変数であり、値の変更も関数が戻るまでしか有効ではありません。それゆえ関数を呼び出したコードの側から見れば、副作用は全く発生していないことになります。

練習問題7

引数にnumber型を取り、その数値の絶対値を返すabsolute関数を書いてください。負の数の絶対値はその数のマイナス符号を外したもので、正の数あるいは０の絶対値は、その数そのものを指すこととします。

解答

absolute = (number) ->

  if number < 0

    -number

  else

    number

show absolute -144

純粋関数には、２つのメリットあります。作り出すのも再利用するのも簡単だということです。

関数が純粋だと、その呼び出しをそれ自体で独立した一つの塊として見なすことができます。もし関数が正しく動作しているか確信がもてない場合、コンソール画面から直接呼び出してテストすることができます。コンテクスト文脈に依存しない分、動作確認が単純シンプルになるのです10。

テストの自動化も容易です。テストを作るのも自動的にできるので簡単です。目的の関数の動作確認をするプログラムを書くだけなのですから。非-純粋関数は様々な条件で異なった値を返し、テストや検証を困難にする副作用を引き起こします。

純粋関数はそれ自身で完結しているため、非-純粋関数に比べて利用価値が高く、様々なシチュエーションに適用することができます。例えばshow関数を見てみましょう。この便利な関数は、前提としてスクリーン上に出力表示用のための特別な領域を必要としています。その出力用の領域が無ければ、この関数は何の役にも立ちません。さてここである関数を考え、format関数と名付けてみます。これは一つの値を引数に取り、その値を表すstring型を返す関数です。この関数はshow関数よりも多くのシチュエーションで使えます。

しかしもちろんformat関数はがshow関数と同じ問題を解決できるわけではありません。show関数の機能は副作用を必要とするため、いかなる純粋関数にもその機能を実現できないのです。多くの場合、問題解決には非-純粋関数を使います。純粋関数で解決できる問題もありますが、非-純粋関数の方がはるかに便利で効率的なものになります。

10厳密に言えば、純粋関数はいかなる外部変数も利用することができません。外部変数は値が変わるかもしれませんし、もし値が変われば、同じ引数でも違う値が返って来ることになるからです。実際、プログラマーは幾つかの値を、変更されることのない「定数」として扱い、この定数のみを利用した関数を純粋関数と呼んでいます。関数値を保持した変数など、定数の典型例です。

従って、もし純粋関数で問題を簡単に記述できる場合、純粋関数を使うべきでしょう。しかし間違っても非純粋関数を嫌ってはいけません。

関数が期待した値を返してくれるかどうかは、どうやって証明すべきでしょうか？先ほどの練習問題では、absolute -144を実行し、正しい答えを得ることができました。シンプルな関数にはこれで充分でしょうが、関数というものは一瞬で途方も無く複雑になり、プログラムコードを読みだけでは戻り値を予測するのが困難になってゆきます。absolute関数がちゃんと動いているか確認するには、もっと多くのテストケースが必要です。しかし、ひたすらテストケースを書き続けるばかりではすぐに飽きが来てしまいます。何かいい方法は無いでしょうか…。

練習問題では、関数が果たすべき機能として次のように書かれていました。「負の数の絶対値はその数のマイナス符号を取ったもので、正の数あるいは０の絶対値は、その数そのものを指すこととします。」この説明を、コンピュータが理解してテストできる「プロパティ」に置き換えてみましょう。

testAbsolute = (name, property) ->

  qc.testPure absolute , [qc.arbInt], name, property

testAbsolute関数はqc (quick check11を意味します)のtestPure関数を呼び出し、最初の引数でabsolute関数をテストするようtestPure関数に指示しています。次の引数arbIntは、absolute関数が「引数に任意の整数値を取ること」を意味しています。角括弧やドット記号は気にしないでください。これらは次章で説明します。testAbsolute関数に分かり易い説明文とプロパティを与えて呼び出すことにより、absolute関数にどのような挙動を求められているのかを定義することができます。

testAbsolute 'returns positive integers',

  (c, arg, result) -> result >= 0

まず関数の説明から、absolute関数が0以上の値を返さなければいけないのは明白です。プロパティ内のresult >= 0がそのことを意味しています。ここでのプロパティは、「テストケース（caseが予約語なので、cを使っています）」「absolute関数を呼び出す時の引数」「absolute関数の戻り値」の、計３つの引数を取る関数です。

11QuickCheckはチャルマース工科大学のKoen ClaessenとJohn HughesがHaskell向けに開発したものですが、他のプログラミング言語用にも次々に再実装されてきています。qcライブラリは、Darrin ThompsonによるJavaScript向けの実装です。CoffeeScript対応版は、preludeに含まれています。



- 48 -

これらの値に応じて、プロパティは「関数が与えられた条件を満たしているかどうか」をtrueあるいはfalseで返します。関数の説明にはこう書いてあります。「正の数あるいは０の絶対値は、その数そのものを指すこととします。」このプロパティには正の数しか必要ありません。guardの呼び出しは、qcに正ではない値を無視するように伝えます。そしてプロパティは戻り値が引数と同じであることをチェックします。

testAbsolute 'positive returns positive',

  (c, arg, result) -> c.guard arg >= 0; result is arg

負の数のチェックももほとんど同じで、違いはマイナス符号だけです。

testAbsolute 'negative returns positive',

  (c, arg, result) -> c.guard arg < 0; result is -arg

ここまでの段階では、関数に必要なプロパティが宣言されただけです。テストは何一つ実行していません。qc.test()を呼び出せばテスト処理が開始され、qcがテスト用データを生成してプロパティのチェックを行います。

Pass: returns positive integers (pass=100, invalid=0)
Pass: positive returns positive (pass=100, invalid=103)
Pass: negative returns positive (pass=100, invalid=90)

素晴らしいですね。absolute関数は、一瞬のうちに300ものテストケースをパスしてくれました。ちなみにinvalidの数は、guard関数の呼び出しによって無効にされたテストケースの数です。テスト値を表示させたい場合、プロパティ内にshow c.argsを入れて下さい。

一方、テストが失敗した場合はどのように表示されるのでしょうか？ではご期待にお応えして、テストを失敗させる格好の素材として、本章の最初の方で紹介したpower関数を取り上げてみましょう。power関数は、標準ライブラリのMath.pow関数と同じ動作をするはずです（もちろん整数を対象にとる場合に限りますが）。

qc.testPure power, [qc.arbInt , qc.arbInt],

  'power == Math.pow for integers',

  (c, base, exponent , result) ->

    result == c.note Math.pow base, exponent

それを確かめるには、まずtestPure関数を呼び出し、power関数が「２つの整数を引数として取る」ことを記述しましょう。そしてプロパティに、power関数の計算結果がMath.pow関数のそれと同じであることを示してやればいいのです。Math.pow関数の戻り値を得るため、c.noteを呼び出して元々の引数を登録しましょう。

fail: power == Math.pow for integers

pass=9, invalid=0

shrinkedArgs=3,-2,9,0.1111111111111111

Failed case:

[ -9,

  -9,

  -387420489,

  -2.581174791713197e-9 ]

このテストは失敗し、qcはなぜ失敗したかを教えてくれます。行の後半に出てくる2つの-9は、qcがテストケース用に生成した引数です。-387420489は、power関数の戻り値です。最後の数値はMath.pow関数から得られたもので、-9-9=-1387420489の近似値になっています。

qc.testPure power, [qc.arbWholeNum , qc.arbWholeNum],

  'power == Math.pow for positive integers',

  (c, base, exponent , result) ->

  result == c.note Math.pow base, exponent

整数用のpower関数は、その対象範囲が広すぎたかもしれません。しかし少なくとも自然数に関してはうまく動作していたのではないでしょうか？前の例のようにguard関数を使ってテストケースの範囲を狭める以外にも、引数の記述を変えるというやり方があります。qcは、引数としてrange型・string型・date型・リスト型など様々な種類の型を扱うことができます。自然数にはarbWholeNumが用意されています。

fail: power == Math.pow for positive integers

pass=28, invalid=0

shrinkedArgs=9,18,150094635296999100,150094635296999140

Failed case:

[ 27,

  27,

  4.434264882430377e+38,

  4.434264882430378e+38 ]

さて今度は28個のテストをパスして、2727で止まりました。どうやら最後の桁の数字が違っているみたいです12。ここでshrinkedArgsと書かれた行に注目してください。qcはテストに失敗すると、同じ問題を発生させるテストの中で、よりシンプルなものを探し出そうとします。ここで言う「シンプル」とはより短い文字列やリストなどのことで、この場合はより小さな数値のことを指します。

12ECMAScriptではJavaScriptに対してこれらの偏差誤差を許容しています。これはもちろんCoffeeScriptにも当てはまります。どうしても完全に誤差の無い整数を扱いたい場合は、サードパーティー製のライブラリを使うか、Pureなどのより数学志向なプログラミング言語を使うことをお勧めします。

qcは918の段階で既に違いを見つけています。power関数の戻り値は100で終わり、Math.pow関数は140で終わっています。果たしてどちらが正しいのでしょうか？どちらも正しくありません13。 正解は918 = 150094635296999121です。

練習問題8

下記のプログラムをコピーして、intensify関数がテストプロパティをパスするように修正して下さい。223ページのqcリファレンスには、arbConstなど多くのqc用語の説明が載っています。preludeをrequireすると、c.noteVerboseが使えます。c.noteVerboseはテスト失敗時に値を記録したり、テスト時に値を表示させたりすることができます。

require './prelude'

intensify = (n) ->

  2

qc.testPure intensify , [qc.arbInt],

  'intensify grows by 2 when positive',

  (c, arg, result) ->

    c.guard arg > 0

    arg + 2 == result

qc.testPure intensify , [qc.arbInt],

  'intensify grows by 2 when negative',

  (c, arg, result) ->

    c.guard arg < 0

    arg - 2 == result

qc.testPure intensify , [qc.arbConst(0)],

  'only non-zero intensify grows',

  (c, arg, result) ->

    result is 0

qc.test()

13この書籍（訳者注：原版のこと）を作る際LYXと呼ばれる文書プロセッサが使われており、計算結果はLYXに統合されているMaximaによるものです。Maximaは、記号演算や精度制限の無い計算を行うことのできるコンピュータ代数システムです。

解答

intensify = (n) ->

  if n > 0

    n + 2

  else if n < 0

    n - 2

  else

    n

関数を書く前にテスト記述を書くことは、関数を把握するのに役立ちます。今までの例で見たように、テスト記述は、テスト対象である関数よりもかなり長いコードになります。二分ヒープには、クラスとそのテストケースのより実際的な例が述べられています。宣言的テストは、テストアルゴリズムおよび再利用可能なライブラリに非常に適しています。他にも好みと作業内容に応じて、さまざまなテストツールが存在します14。ここで強調しておきたいことは、「適切なレベルのテストを行うことは、コーディングの一部である」ということです。

関数の話に戻ります。関数は、return文は必須ではありません。return文無しで関数処理が終わった場合、関数は最後の命令文の値を戻り値とします。preludeのshow関数は、自身の引数をそのまま返すので、表現式の中で使うことができます。もしundefinedを返したい場合は、最後の命令文を「return」にします。

yell = (message) ->

  show message + '!!'

  return

yell 'Yow'

関数の引数は、内部変数のように利用できます。関数は呼び出し時の引数を参照しますが、これらは内部で定義された他の変数と同様、関数外では利用できません。また関数はトップレベルスコープとは別に、小さなローカルスコープを生成します。変数を参照する際、関数はまず外部スコープをチェックし、そこに変数が見つからない場合のみ、ローカルスコープに変数を生成します。

14CoffeeScriptはほとんどのJavaScript用テストツールに対して互換性があり、簡単に利用することができます。

dino = 'I am alive'

reptile = 'I am A-OK'

meteor = (reptile) ->

  show reptile # Argument

  dino = 'I am extinct'

  reptile = 'I survived'

  possum = 'I am new'

show dino # Outer

meteor 'What happened?'

show dino # Outer changed

show reptile # Outer unchanged

try show possum catch e

  show e.message # Error undefined

これによって、引数は同じ名前を持つ外部変数を「隠蔽する」ことができます。変数を扱うのに一番いい方法は、ファイル内で全ての変数にユニークな名前を付けることです。トップレベル変数は、明示的にエクスポートしない限りファイル間で共有することはできません。詳しくはモジュラー性を参照して下さい。



従って関数内部の変数名が外部スコープにも存在した場合、その変数は外部スコープを参照しているものであって、新しく定義されたものではありません。variable = ‘何とか’ のような表現式は、新しい変数の定義かもしれませんし、あるいは既存の変数に代入しているだけかも知れません。

トップレベル変数を使う場合には、ファイルの先頭部分でその変数を宣言してデフォルト値を与えておくのが、形式としては理想的です。





variable = 'first' # Definition

showVariable = ->

  show 'In showVariable , the variable holds: ' +

        variable # second

test = ->

  variable = 'second' # Assignment

  show 'In test, the variable holds ' +

        variable + '.' # second

  showVariable()

show 'The variable is: ' + variable # first

test()

show 'The variable is: ' + variable # second

ローカルスコープで定義された変数は、関数内のコードでしか有効ではありません。関数がさらに別の関数を呼び出した場合、新しく呼び出された関数からは、呼び出し元の関数にある変数が見えないのです。

andHere = ->

  try show aLocal # Not defined

  catch e then show e.message

isHere = ->

  aLocal = 'aLocal is defined'

  andHere()

isHere()

ここで一つ、些細ではありますが極めて役に立つ仕組みを紹介しておきます。それは「関数が別の関数内で定義された場合、内側の関数のローカルスコープは、それを囲むローカルスコープをベースにする」ということです。

isHere = ->

  andHere = ->

    try show aLocal # Is defined

    catch e then show e.message

  aLocal = 'aLocal is defined'

  andHere()

isHere()

さらにこのケースをご覧ください。きっとビックリすると思います。

varWhich = 'top-level'

parentFunction = ->

  varWhich = 'local'

  childFunction = ->

    show varWhich

  childFunction

child = parentFunction()

child()

parentFunction関数は内部関数を返し、コードの最後でその関数を呼び出しています。parentFunction関数はこの時点でとっくに処理を終えていますが、変数が値「local」を保持したローカルスコープはまだ残っています。従ってchildFunction関数はその値を参照するわけです。この仕組みをクロージャと呼びます。

スコープを使うことによって、関数を「統合する」ことができます。内部関数が、自身を包括する関数内の変数を使うことによって、さまざまな処理が可能になります。例えば引数に２を足す関数、５を足す関数などのように、機能的にはほとんど同一の関数を考えてみてください。

makeAddFunction = (amount) ->

  add = (number) -> number + amount

addTwo = makeAddFunction 2

addFive = makeAddFunction 5

show addTwo(1) + addFive(1)

スコープ化の法則により、異なる関数が同じ名前の変数を使っても衝突せず、さらに関数が自分自身を呼び出しても何の問題も生じないのです。関数が自分自身を呼び出すことを、再帰と呼びます。再帰関数は少々変わった定義の仕方をします。再帰関数を定義するにはまず停止条件が必要です。さもなければ、せっかく丁寧に作った再帰関数も、無限ループに陥ることになります。このpower関数を見てください。

powerRec = (base, exponent) ->

  if exponent == 0

    1

  else

    base * powerRec base, exponent - 1

show 'power 3, 3 = ' + powerRec 3, 3

これは数学者が定義したべき乗に近く、筆者から見ても以前のバージョンよりもはるかに良いものに見えます。これはある種のループではありますが、whileも無くforも無く、さらにはローカルな副作用も存在しません。関数は自分自身を呼び出して、同じ処理を繰り返します。自分自身を呼び出す事で、関数は同じ効果を得る事ができます。停止条件はexponent変数が0になることであり、関数は呼び出しのたびにexponent変数から１を引き0に近づけてゆきます。もしpowerRec関数を再利用可能なライブラリ化した場合、exponent変数が自然数であるという前提条件を明確にドキュメント化しなければいけません。

コードを簡潔にすることで、パフォーマンスに影響が出てくるでしょうか？それを確かめるには、方法は一つしかありません。実際に計測してみることです。下に挙げたのは筆者のPCによる実行結果です。あくまでも一例としてお考えください。CPU、オペレーティングシステム、コンパイラー、ブラウザのインタープリタなどの全てがパフォーマンスに影響してきます。ですので可能な限りターゲット環境に近い状況で計測してください。

timeIt = (func) ->

  start = new Date()

  for i in [0...1000000] then func()

  show "Timing: #{(new Date() - start)*0.001}s"

timeIt -> p = add 9,18 # 0.042s

timeIt -> p = Math.pow 9,18 # 0.049s

timeIt -> p = power 9,18 # 0.464s

timeIt -> p = powerRec 9,18 # 0.544s

実行速度とコードの読み易さとのトレードオフは、考慮に値するテーマです。またこの問題は、再帰関数を採用するか否かという場面に限らず出てきます。多くのケースで、読み易く直感的かつコンパクトな解法が、より複雑でしかし早い解法に取って代わられることがあります。

先に出てきたpower関数はエレガントではないものの、十分にシンプルで読み易くなっています。これを再帰版に代えることは、あまり意味があるとは言えません。プログラムの扱う内容があまりに複雑化した場合、多少の処理効率を捨てて、プログラムを簡略化するのもいいかもしれません。

多くのプログラマが繰り返し指摘している基本ルールに、「プログラムの速度がよっぽど遅いんじゃない限り、効率性の心配なんて無用だ」というものがあります。筆者もこれには大いに賛成します。修正が必要になったら、どの部分がネックになっているのかを見つけ出し、その可読性を効率性へと替えてゆきましょう。もちろんこのルールは、パフォーマンスを完全に無視してコーディングを進めてもいいという意味ではありません。power関数に見られるように、「エレガント」なアプローチでもそれほどシンプルにならないというケースが良くあります。一方で熟練プログラマは、シンプルなアプローチが決して早くはならないことを一瞬で見抜きます。

私がこの問題を口を酸っぱくして言い続けるのも、あまりに多くのプログラマが、誤った考えに基づいて、取るに足らない些細な効率性を重視しすぎているからです。

その結果、巨大でより複雑な、そしてしばしば正確さに欠けたプログラムが誕生します。素直な書き方よりも時間をかけた割には、大した速度向上も望めない代物です。

もしシンプルで正しい実装ではあるものの、あまりにも遅いコードがあった場合、それは改良版をテストする時の参考として使うことができます。まず第一に考えなければいけないこと、それは、直面している問題を扱うにはどのようなデータ構造やアルゴリズムが必要かということです。例えば１０個の要素が入ったリストを検索するのと１００万個の要素が入ったリストを検索するのでは、大きな違いがあります。この種の問題は、検索でより深く掘り下げられています。

ところで、筆者は再帰について話していました。再帰と深く関係のある概念の一つに、スタックというものがあります。関数が呼ばれたとき、コントロール制御は関数本体に渡されます関数の内部に制御が移ります。関数本体から戻るとき、関数を呼び出した側のコード処理が再開します。関数本体の実行中、コンピュータは関数を呼び出したコンテクストを保持し、その後の処理の続行に備えておかなければいけません。コンテクストが保存される場所は、スタックと呼びます。

スタック（訳者注：日本語で「積み重ね」の意味）と呼ばれるには理由があります。まずお分かりの通り、関数本体は、他の関数を呼び出すことができます。関数が呼ばれるたびに、コンテクストをその都度保存しなければいけません。これを、コンテクストが積み重なってゆくイメージとして捉えてみて下さい。関数が呼ばれるたびに、現在のコンテクストがスタックの一番上に置かれます。関数が戻ったとき、一番上のスタックが取り除かれ処理が再開されます。

スタックはコンピュータのメモリ上に保存されます。スタックが大きくなりすぎたとき、コンピュータは「スタックスペースが足りません」や「再帰が多すぎます」などのエラーメッセージを表示します。

ですので再帰関数を書く際には、必ずスタックの存在を念頭に入れておいて下さい。

chicken = ->

  show 'Lay an egg'

  egg()

egg = ->

  show 'Chick hatched'

  chicken()

try show chicken() + ' came first.'

catch error then show error.message

これは間違ったプログラムの書き方ですが、非常に興味深い特徴があります。この例は、関数が再帰的であるためには、必ずしも自分自身を直接呼び出さなくても良いということを示しているのです。直接的であれ間接的であれ、別の関数が最初の関数を再び呼び出せば、これは立派な再帰といえます。tryとcatchについては、例外処理で述べられています。

再帰関数は、必ずしもループよりも非効率的な代替手段というわけではありません。幾つかの問題では、ループよりも再帰関数を使った方がはるかに解きやすいものがあります。よくある例として、何本もの「枝」があり、各々の枝がさらに幾つもの枝を生やしているような構造を探索・処理する問題が挙げられます。

次のパズルを考えてみてください。１から始めて、毎回前の数に5を足すか3を掛けるかして、無限に数を生成してゆく様を想像してみてください。そしてある数に対して、どのような順番で足し算や掛け算を処理したらその数に行き着いたかを見つけ出す関数を作って下さい。例えば13は、まず1に3を掛けてそれから5を2回足した数字です。一方15には、どう計算してもたどり着くことはできません。

findSequence = (goal) ->

  find = (start, history) ->

    if start == goal

      history

    else if start > goal

      null

    else

      find(start + 5, '(' + history + ' + 5)') ? \

      find(start * 3, '(' + history + ' * 3)')

  find 1, '1'

show findSequence 24

気をつけて欲しいのは、見つかった解は必ずしも最短の計算過程による結果ではない、ということです。この関数は、最初に見つかった計算過程を返すだけです。

内部のfind関数は、現在の数に5が足されるのか、あるいは3が掛けられるかを求めるために、自分自身を2種類の方法で再帰呼び出ししてゆきます。関数は目的の数に到達すると、文字列historyを返します。この変数には、関数がその数にたどりつくまでに実行した演算の履歴が収められています。またこの関数は、現在の数値と目標値を比較しています。現在値が目標値より大きければ目標値に辿り着くことは不可能であり、その枝の探索を打ち切ることになります。

ここにある存在演算子「?」は、「startに5を足した結果発見した解法を返す。もしそれが失敗したら、startに3を掛けた結果発見した解法を返す」という風に使われています。

通常関数を定義するときは、後で参照して呼び出せるように名前をつけてやります。ただ関数名は必須ではなく、名前を付けない方が良いケースもあります。そんな時は代わりに匿名関数を使いましょう。

例として、先ほど見たmakeAddFunction関数を少し変えてみます。

makeAddFunction = (amount) ->

  (number) -> number + amount

show makeAddFunction(11) 3

最初のバージョンのmakeAddFunction 関数にあったadd関数は一度しか参照されなかったため、名前は全く役に立っていません。そのため、関数値を直接戻したほうが理に適っているでしょう。

練習問題9

number型である引数を一つ取り、数値比較テスト関数を返すgreaterThan関数を書いて下さい。戻り値である関数も一つのnumber型を引数に取り、次のようにboolean型を返します。すなわち、与えられた数値がテスト関数を作った時の数値より大きかったらtrueを返し、そうではない場合はfalseを返します。

解答

greaterThan = (x) ->

  (y) -> y > x

greaterThanTen = greaterThan 10

show greaterThanTen 9

次の命令文を試してみてください。

yell ‘こんにちは’, ‘こんばんは’, ‘元気？’

本章の最初のほうで定義されたyell関数は、引数を一つしか取ることができません。このように呼び出した場合、コンピュータは何一つ文句を言わず、黙って他の引数を無視します。

yell()

当然ながら、少ない引数で関数を実行することもできます。引数を指定しなかった場合、関数内部での引数の値はundefinedになります。

次章では、関数本体が複数の引数をリストとしてひとかたまりに受け取る方法を紹介します。これは、関数が引数を何個でも取ることができるという便利な機能です。

おかげで、console.logをこのように呼び出すことができます。

console.log 'R', 2, 'D', 2

もちろん逆に、関数が決まった数の引数を取るにもかかわらず、間違った数の引数を渡してしまい、しかもそれに気付かないというケースもあり得ます。



Takaichi Kubo

Takashi Tsuda

Tsutomu Kawamura

Takahiro Yoshida

-Main translator

Yayoi Kinosita

##<a name = "データ構造">データ構造</a>: オブジェクトと配列

この章はいくつかの単純な問いを解くのにあてられます。その過程において、2つの新しい値の型、すなわち配列(array)とオブジェクト(object)について論じ、それに関連するいくつかのテクニックを見ていきます。

次の状況を考えてみましょう: クレイジーエイミーおばさんが——彼女には一緒に暮らしている猫が50匹以上いると噂されている(あなたはうまく数えられた試しがありません)のですが——、あなたに彼女の偉業の最新情報を報せるために定期的にe-mailを送って来ます。内容はいつもこんな感じです: 

親愛なる私の甥へ

あなたのお母さんからスカイダイビングを始めたって聞いたけど、本当なの? 

ちょっとあなた、よく考えて! わたしの夫に何が起こったか覚えてないの? 

それにあれだってたったの2Fだったのよ!

それはともかく、ここは全てが素晴らしく面白いわよ。わたしは週の全てを費やしてお隣に越してきた素敵な紳士ドレイクさんの気を引こうと試してみたけど、あの人は猫を怖がっているんじゃないかしら？それとも、猫アレルギー? 次に会ったら、太っちょイゴールをあの人の肩の上に置いてみるつもりよ。何が起きるかとても楽しみだわ。

あと、あなたに教えた例の儲け話は思いの外うまくいってるわ。もう既に5件の「支払金」が返って来ていて、申し立ては1件だけ。ちょっと悪い気がして来てはいるのだけれど。まあ、違法なんじゃないのって意見は、あなたが正しいわね。

(...中略...)

それでは

叔母エミリーより

died 27/04/2006: Black Leclère

born 05/04/2006 (mother Lady Penelope): Red Lion, Doctor Hobbles the 3rd, Little Iroquois

おばさんに調子を合わせるには、彼女の猫の血統を把握しておきたいところ。そうしたら、あなたはこんな感じに続けてもいいでしょう——「追伸、この土曜にドクターホブルズ2世が彼の誕生日を楽しんだならよいのですが。」または「大きくなったレディー・ペネロペはいかがお過ごしですか? 彼女は今5歳でしたよね?」というように——うっかり死んだ猫について尋ねないように気を付けて。あなたには叔母からの古いe-mailが大量にあります。そして幸いなことに、彼女は常に一貫して、猫の出生と死亡についての情報を、メールの終わりに正確に同じ形式で付記しています。

あなたは手動でそれらのメール全てを、進んで調べる気にはなれませんよね。幸いにも、我々はちょうど何かしらの例題を必要としていたので、我々のために動くプログラムを作ってみます。まず始めに、最後のe-mailでもまだ生きている猫のリストを与えるプログラムを書きます。

あなたが尋ねる前、通信の開始と同時に、叔母エイミーはSpot(スポット、ぶち)というたった1匹だけ独身の猫を飼っていました。(その当時、まだ彼女はわりと普通でした。)



タイプし始める前に、動こうとしているあるプログラムの何らかの手がかりを持っていることはたいてい有益である。プラン(計画、設計?)は以下の通りです: 

“Spot”だけが入っている猫の名前の集合から始める。
“born”または“died”で始まる段落を探す。
“born”で始まる段落にある名前を我々の名前の集合に加える。
“died”で始まる段落にある名前を我々の集合から取り除く。
ここで、ある段落から名前を取り出すことは以下のようになります: 

コロン(:)を段落から見つける。
このコロンの後の部分を取り出す。
カンマ(,)を探すことによって、この部分を別々の名前に分割する。
これを受け入れるには、いくつかの不信、叔母エイミーが常にこの正確な形式(体裁?)を用いているとか、彼女は決して名前を書き忘れたりスペルを間違えたりはしないとか、を一時的に止めることを求められるかもしれませんが、しかしそれこそがあなたの叔母らしいところ(叔母たらしめているところのもの、叔母たる所以?)なのです。

まず、プロパティについて話させて下さい。ほとんどのCoffeeScriptの値はそれらの値と結びついた他の値を持っています。それらの結びつきはプロパティと呼ばれています。全ての文字列はlengthと呼ばれるプロパティを持ち、そのlengthはその文字列に含まれる文字の総数である数を参照します。

text = 'purple haze'

show text['length']

show text.length

2番目の方法は1番目の省略表現であり、そのプロパティの名前が妥当な変数名であるときだけ働(動)きます—それ(その変数名)が何の空白も記号もその中に持たないとき、かつ、数字で始まらないときに。

nothing = null

show nothing.length

数値(Numbers)、真偽値(Booleans)、null値、undefined値はどんなプロパティも持ちません。そのような値からプロパティを読もうとするとエラーが生じます。このような(いくつかのブラウザに関しては、かなり不可解(暗号的?)かもしれない(ちょっと隠れているかもしれない?))場合にあなたの得るエラーメッセッージの種類についての知識(idea)を得るためにも、次のコードを試しなさい。

ある文字列のそのプロパティの値は変えられません。それらはlengthだけでなくかなりの種類がありますが、これから見ていくように、あなたは何か加えたり取り除いたりすることを許されてはいません。

これはオブジェクト型の値とは異なります。それらの主な役割は他の値を持っておく(保持する?)ことです。それらは、言わば、プロパティという形でそれら自身の触手の集合を持っていると言えるでしょう。あなたがそれらを変更すること、取り除くこと、新しいものを付け加えることは自由です。

あるオブジェクトはこのように記述されます: 

cat =

    colour: 'grey'

    name: 'Spot'

    size: 46

# Or: cat = {colour: 'grey', name: 'Spot', size: 46}

cat.size = 47

show cat.size

delete cat.size

show cat.size

show cat

変数のように、あるオブジェクトに付随する各プロパティはある文字列によって名付けられます。最初の記述がオブジェクトを作り出し、そのオブジェクトのプロパティ'colour'は文字列'grey'を保持し、そのオブジェクトのプロパティ'name'は文字列'Spot'に付随されており、そのオブジェクトのプロパティ'size'は数46を参照(指示?)しています。その次の記述はsizeと名付けられたプロパティに新しい値を与えています。変数を変更するのと同じような方法で行われています。

deleteという用語(キーワード?)はプロパティを削除します。値undefinedを与える存在しないプロパティを読んでみなさい。

まだ存在しないプロパティが = 演算子(オペレーター?)で定められたとすると、それ(そのプロパティ)はオブジェクトに加えられます。

empty = {}

empty.notReally = 1000

show empty.notReally

妥当な変数名ではない名前のプロパティは、オブジェクトを生成する際にコーテーションで囲う必要があり、呼び出すにも括弧を使う必要があります: 

thing = {'gabba gabba': 'hey', '5': 10}

show thing['5']

thing['5'] = 20

show thing[2 + 3]

delete thing['gabba gabba']

show thing

ご覧の通り、括弧の間の部分はどんな表現も可能です。それは、それを参照する(示す?)プロパティ名を決定するために文字列に変換されます。プロパティを名付けるために用いるのは変数でも大丈夫です: 

propertyName = 'length'

text = 'mainline'

show text[propertyName]

ofという演算子はオブジェクトがあるプロパティを持つかどうかをテストするのに利用できます。それは真偽値を生じます。

chineseBox = {}

chineseBox.content = chineseBox

show 'content' of chineseBox

show 'content' of chineseBox.content

show chineseBox

オブジェクトの値がコンソールに表示されているとき、プロパティの最初の何層かだけしか表示されません。もっと層を調べるために、あなたはshowにdepthという追加引数を与えることができます。

abyss = {let:1, us:go:deep:down:7}

show abyss

show abyss, 5

練習10

猫問題のための解決は名前の「集合」について言及します。集合とは複数回同じ値が現れないような値の集まりです。もし名前が文字列なら、名前の集合を表すためにオブジェクトを使う方法を考えられますか?

名前がこの集合にどのようにして加えられるか、どのようにして取り除かれるかを示し、また、どのようにしてある名前がその中に現出しているかどうか調べられるかを示しなさい。

解決

これはオブジェクトのプロパティとして集合の内容を格納することで成し得ます。

名前を追加は、ある値、すなわち任意の値、にその名前でプロパティを設定することによって成されます。名前の削除は、このプロパティを削除することで成されます。of 演算子はある特定の名前が集合の一部であるかどうかを判定するのに使えます。このアプローチに関していくつか微妙な問題がありますが、それはオブジェクト指向Object Orientationにおいて議論され解決されるでしょう。この章に関しては、これで十分です。

set = {'Spot': true}

# Add 'White Fang' to the set

set['White Fang'] = true

# Remove 'Spot'

delete set['Spot']

# See if 'Asoka' is in the set

show 'Asoka' of set

明らかに、オブジェクトの値は変えられます。Basic CoffeeScriptにおいて検討された値の型は全く不変であり、それらの型が存在するある値を変えることは不可能です。あなたはそれらを組み合わせることができ、それらから新しい値を追い出すことができます。しかし、あなたが特定の文字列の値を使うとき、その中の文字列は変えられません。一方で、オブジェクトについては、その値の内容はそのプロパティを変えることによって変更可能です。

2つの数120と120があるとき、それらは実際上は正に同じ数と考えられます。オブジェクトとしては、同じオブジェクトへの2つの参照を持つことと同じプロパティを内包する異なるオブジェクト2つを持つことの間には違いがあります。次のコードを考えなさい:

object1 = {value: 10}

object2 = object1

object3 = {value: 10}

 

show object1 == object2

show object1 == object3

 

object1.value = 15

show object2.value

show object3.value

object1とobject2は正に同じ値を保持する2つの変数です。実際のオブジェクトはたった1つだけですので、object1を変えることは、object2の値もまた変えるのです。変数object3はもう一つのオブジェクトを指し示しています。それは初めにobject1と同じプロパティを含んでいましたが、別々の道を歩みます。

CoffeeScriptの==演算子は、オブジェクト同士を比較すると、もしそれに与えられた両方の値が正に同じ値であれば、trueのみを返すでしょう。全く同一の内容を持つ異なる値を比較することはfalseを与えるでしょう。このことは何らかの場面で役立ちます。しかし、他のところでは(他人には?)非実用的です。

15underscore libraryにおいて、あなたはそれらの内容の全ての層に基づいて2つのオブジェクトを比較するisEqualという関数を見つけることができます。

オブジェクトの値は多くの異なる役割を果たすことができます。集合のように振る舞うことはそのうちのたった1個に過ぎません。我々はいくつかの他の役割をこの章の中でみていきます。そして、Object Orientationではもう一つの重要なオブジェクトの使い方を示します。

猫問題のためのプランにおいて—実際、これはプランではなく、アルゴリズムと呼びましょう、それは我々が何について話しているか我々は知っているように思わせるが—そのアルゴリズムにおいて、あるアーカイブの中の全てのe-mailを探索することについて話しています。このアーカイブは何のようにみえますか?そして、それはどこから来るのでしょうか?

Do not worry about the second question for now. Modularity talks about some ways to import data into your programs, but for now you will find that the e-mails are just magically there. Some magic is really easy, inside computers.

今は2番目の問いについては心配することはありません。いまあなたがまるで魔法のようにそこにe-mailが存在することを発見できなければ、Modularityではいくつかのあなたのプログラムへのデータの取り込み(インポート?)方法について話します。いくつかの魔法はコンピュータの中では本当に簡単です。

○•○

The way in which the archive is stored is still an interesting question. It contains a number of e-mails. An e-mail can be a string, that should be obvious. The whole archive could be put into one huge string, but that is hardly practical. What we want is a collection of separate strings.

そのアーカイブが格納されるその方法はまだ関心を引く問いです。それは多くのe-mailの数を含有しています。明らかに、一つのe-mailは文字列であり得ます。アーカイブ全体は一つの巨大な文字列にまとめられるが、あまり実用的ではありません。我々が求めているのは分離した文字列の集まりです。

Collections of things are what objects are used for. One could make an object like this:

mailArchive = {

   'the first e-mail': 'Dear nephew , ...'

   'the second e-mail': '...'

   # and so on ...

}

そして「ものごとの集まり」を表現するのは、まさにオブジェクトの使いどころです。例えばこのような形でオブジェクトを作ることができます。: 

mailArchive = {

   'the first e-mail': 'Dear nephew , ...'

   'the second e-mail': '...'

   # and so on ...

}

But that makes it hard to go over the e-mails from start to end — how does the program guess the name of these properties? This can be solved by more predictable property names:

mailArchive = {

   0: 'Dear nephew , ... (mail number 1)'

   1: '(mail number 2)'

   2: '(mail number 3)'

}

for current of mailArchive

   show 'Processing e-mail #' + current +

        ': ' + mailArchive[current] 

しかし、それは最初から最後まで電子メールを探索することを困難にします―どのようにしてプログラムがこれらのプロパティの名前を推量するのですか?これはもっとありきたりなプロパティ名によって解決することができます: 

mailArchive = {

   0: 'Dear nephew , ... (mail number 1)'

   1: '(mail number 2)'

   2: '(mail number 3)'

}

for current of mailArchive

   show 'Processing e-mail #' + current +

        ': ' + mailArchive[current]

Luck has it that there is a special kind of objects specifically for this kind of use. They are called arrays, and they provide some conveniences, such as a length property that contains the amount of values in the array, and a number of operations useful for this kind of collections.

幸運なのは(?)特にこの種の使用のための特別な種類のオブジェクトがあるということです。それらは配列と呼ばれ、配列に値の量を含んでいる"length"プロパティのようないくつかの利便なものと、この種の集まりとって便利ないくつかの演算子を備えています

(提供します、もたらします?)。

New arrays can be created using brackets ([ and ]). As with properties, the commas between elements are optional when they are placed on separate lines. Ranges and for comprehensions also create arrays.

mailArchive = ['mail one', 'mail two', 'mail three']

for current in [0...mailArchive.length]

show 'Processing e-mail #' + current +

': ' + mailArchive[current]

新しい配列は括弧("["と"]")を使って作り出すことができます。プロパティと同様、別々の行(ライン?)に置かれる場合は要素間のカンマは任意(省略可能)です。範囲も、また内包に関してもまた配列を作り出します。

mailArchive = ['mail one', 'mail two', 'mail three']

for current in [0...mailArchive.length]

show 'Processing e-mail #' + current +

': ' + mailArchive[current]

In this example, the numbers of the elements are not specified explicitly anymore. The first one automatically gets the number 0, the second the number 1, and so on.

この例において、その要素の数はもうこれ以上明確に特定されていません。最初のものは自動的に数0を得、第2番目のものは数1を得、...。

Why start at 0? People tend to start counting from 1. As unintuitive as it seems, numbering the elements in a collection from 0 is often more practical. Just go with it for now, it will grow on you.

何故0から始めるのでしょうか?人は1から数え始める傾向があります。見かけ通り非直観的として、0からの集まりの要素に番号付けすることはしばしば(多くの場合、たいてい)より実用的です。今はとにかくこのままいってみましょう、そのうち身に付くようになります。

Starting at element 0 also means that in a collection with X elements, the last element can be found at position X - 1. This is why the for loop in the example uses an exclusive range 0...mailArchive.length. There is no element at position mailArchive.length, so as soon as current has that value, we stop looping.

要素0から始めることは、要素Xで集めたものの中のものもまた意味しており、最後(最新?)の要素は場所 X - 1で見つけることができます。こういう訳で、例におけるforループは排他的な範囲 0...mailArchive.lengthを使うのです。場所mailArchive.lengthに要素はありません。したがって、"current"がその値を持つとすぐに、我々はループを止めます。

Exercise 11

Write a function range that takes one argument, a positive number, and returns an array containing all numbers from 0 up to and including the given number.

An empty array can be created by simply typing []. Also remember that adding properties to an object, and thus also to an array, can be done by assigning them a value with the = operator. The length property is automatically updated when elements are added. 

練習11

1つの引数、正の数、をとり、0から上の全ての数を含んでいて、与えられた数を含有する配列を返す関数rangeを書きなさい。空の配列は単に[]をタイプすることで作り出すことができます。また、あるオブジェクトにプロパティを追加することを思い出せば、ある配列にもまた、=演算子でそれらにある値を割り当てることによって可能になります(可能となることを思い出しなさい?)。要素が追加される場合、そのlengthプロパティは自動的に更新されます。

Solution

range = (upto) ->

  result = []

  i = 0

  while i <= upto

    result[i] = i

    i++

  result

show range 4

Instead of naming the loop variable counter or current, as I have been doing so far, it is now called simply i. Using single letters, usually i, j, or k for loop variables is a widely spread habit among programmers. It has its origin mostly in laziness: We’d rather type one character than seven, and names like counter and current do not really clarify the meaning of the variable much. 

If a program uses too many meaningless single-letter variables, it can become unbelievably confusing. In my own programs, I try to only do this in a few common cases. Small loops are one of these cases. If the loop contains another loop, and that one also uses a variable named i, the inner loop will modify the variable that the outer loop is using, and everything will break. One could use j for the inner loop, but in general, when the body of a loop is big, you should come up with a variable name that has some clear meaning. 

In CoffeeScript the solution can be written in much shorter forms using a for expression that collects the results or by using the built-in range.

range = (upto) -> i for i in [0..upto]

show range 4

range = (upto) -> [0..upto]

show range 4

解決

range = (upto) ->

  result = []

  i = 0

  while i <= upto

    result[i] = i

    i++

  result

show range 4

そのループ変数をcounterまたはcurrentと名づける代わりに、私がこれまでやってきたように、今それは単にiと呼ばれます。ループ変数に通常i、jあるいはkという単一の文字を使用することは、プログラマの間では広く普及している習慣です。それは主に怠惰から来ています: 我々は7文字より1文字をむしろタイプしたい。それに、counterとかcurrentのような名前は本当のところ、そんなに変数の意味を明確にはしていません。

もしプログラムがあまりにも多くの無意味な単一文字の変数を使うなら、それは信じられないほど混乱させるようになるでしょう。私自身のプログラムにおいては、私は少しの共通の場合にだけこれをすることにしようと試みて(努力して)います。小さなループはこれらの場合のうちの1つです。ループが別のループを含んでおり、それもまたiという名の変数を使用しているとすると、内部のループは外部のループが使用している変数を修正するでしょう。すると、すべてが壊れます(ブレイクします?)。誰もが内部のループのためにjを使用してもかまわないが、一般に、ループの本体が大きいとき、あなたは何か明瞭な意味を持つ変数名を考え出すべきです。

CoffeeScriptにおいては、解決は、結果を集めるfor表現を使用して、あるいはその内蔵の範囲を使うことによって、はるかに短い形式で書くことができます。

range = (upto) -> i for i in [0..upto]

show range 4

range = (upto) -> [0..upto]

show range 4 



In CoffeeScript most statements can also be used as expressions. That means for example that the values from a for comprehension can be collected in a variable and used later.
CoffeeScriptでは、ほとんどの命令文は式としても使えます。例えばfor節の値を変数に集めて後で使うことができる、といったことをこれは意味します。

numbers = (number for number in [0..12] by 2)
show numbers

○•○
Both string and array objects contain, in addition to the length property, a number of properties that refer to function values.
文字列も配列オブジェクトも、lengthプロパティに加えて、関数値を参照するいくつかのプロパティを含んでいます。

doh = ’Doh’
show typeof doh.toUpperCase
show doh.toUpperCase()
Every string has a toUpperCase ↓ property. When called, it will return a copy of the string, in which all letters have been converted to uppercase. There is also toLowerCase ↓. Guess what that does.
すべての文字列はtoUpperCaseプロパティを持ちます。呼ばれると、すべての文字を大文字にへ置き換えた文字列のコピーを返します。toLowerCaseもあります。何をするものか考えてみましょう。
Notice that, even though the call to toUpperCase does not pass any arguments, the function does somehow have access to the string ’Doh’ , the value of which it is a property. How this works precisely is described in Object Orientation↓.
Properties that contain functions are generally called methods↓, for example ‘toUpperCase is a method of a string object’.
toUpperCaseの呼び出しが引数を渡さないにもかかわらず、関数がどうやってかプロパティの持つ値である’Doh’文字列にアクセスしている点に、注意してください。これがどのようにして正しく動作するかは「オブジェクト指向」の章で述べられます。関数プロパティは一般的にメソッドと呼ばれ、たとえば「toUpperCaseは文字列オブジェクトのメソッド」です。

mack = []
mack.push ’Mack’
mack.push ’the’
mack.push ’Knife’
show mack.join ’ ’
show mack.pop()
show mack
The method push ↓, which is associated with arrays, can be used to add values to it. It could have been used in the last exercise, as an alternative to result[i] = i . Then there is pop ↓, the opposite of push : it takes off and returns the last value in the array. 
join ↓ builds a single big string from an array of strings. The parameter it is given is pasted between the values in the array.
配列用のpushメソッドは値を追加するのに使えます。最後に出てきた練習問題で、result[i] = iの代わりの手段としても使うことが出来たでしょう。そして、pushの逆のpopというメソッドもあります。これは、配列の最後の値を取り去って、その値を返します。joinはひとつの大きな文字列を(文字列の)配列から作成します。与えられたパラメータは配列内の値と値の間に挿入されます。
○•○
Coming back to those cats, we now know that an array would be a good way to store the archive of e-mails. In this book, the retrieveMails after the require can be used to (magically) get hold of this array. The magic will be dispelled in Modularity↓. Going over them to process them one after another is no rocket science anymore either:
猫の話に戻って、配列がEメールのアーカイブ情報を保存するのに、良い方法だということがわかります。この本では、requireの後のretrieveMailsメソッドは(魔法のように)この配列を取得できるものとします。この魔法は「モジュラリティ」と唱えられることもあります。Eメールをひとつずつ処理するのは難しいことではありません:

mailArchive = (require "./04-emails").retrieveMails() 
​
for email, i in mailArchive
  show "Processing e-mail ##{i} #{email[0..15]}..."
  # Do more things...
In a for ... in statement we can get both the value and its index in the array. The 
email[0..15] gets the first snippet of each email. We have also decided on a way to represent the set of cats that are alive. The next problem, then, is to find the paragraphs in an e-mail that start with ’born’ or ’died’ .
for...in文の中で、配列の値とそのインデックスを取ることができます。email[0..15]は、それぞれのメールの最初の断片を取り出します。私たちは、生きている猫の集合の表現方法を決めたところでした。次の問題は「born」か「died」ではじまるメールの段落を見つけ出すことです。
○•○
The first question that comes up is what exactly a paragraph is. In this case, the string value itself can not help us much: CoffeeScript’s concept of text does not go any deeper than the ‘sequence of characters’ idea, so we must define paragraphs in those terms.
Earlier, we saw that there is such a thing as a newline character. These are what most people use to split paragraphs. We consider a paragraph, then, to be a part of an e-mail that starts at a newline character or at the start of the content, and ends at the next newline character or at the end of the content.
そうなると最初の疑問は、段落とは何なのか。この場合、文字列の値そのものはあまり助けになりません。CoffeeScriptにおけるテキスト には、「文字の連なり」以上の深い意味(コンセプト)はありません。段落ラグラフとは何かを、そういった用語で定義する必要があるのです。改行文字のようなものがある、ということをこれまでのところで見て来ました。これは、ほとんどの人が段落を分けるのに使うものです。そのでは私たちは、段落をEメールの一部で、かつ、改行文字から始まる、あるいは内容の先頭から始まり、かつ、次の改行文字か内容の最後まで、と考えることにしましょう。
And we do not even have to write the algorithm for splitting a string into paragraphs ourselves. Strings already have a method named split↓, which is (almost) the opposite of the join method of arrays. It splits a string into an array, using the string given as its argument to determine in which places to cut.
そして、文字列を段落に分けるアルゴリズムを自分自身で各必要はありません。文字列にはもともとsplitメソッドがあり、(ほぼ)配列のjoinメソッドの逆になります。これは文字列を配列に分け、引数に渡された文字列をどこで区切るかの判定に使います。

words = ’Cities of the Interior’
show words.split ’ ’
Thus, cutting on newlines (’\n’ ), can be used to split an e-mail into paragraphs.
つまり、改行文字(「\n」)で切れば、Eメールを段落に分けることができるのです。

Exercise 12
split and join are not precisely each other’s inverse. string.split(x).join(x) always produces the original value, but array.join(x).split(x) does not. Can you give an example of an array where .join(’ ’).split(’ ’) produces a different value?
練習問題12
splitとjoinは正確には、それぞれの逆にはなっていません。string.split(x).join(x)は常に元々の値になりますが、array.join(x).split(x)はそうではありません。.join(‘ ‘).split(‘ ‘)が異なる値になる例を示せますか?
 Solution
array = [’a’, ’b’, ’c d’]
show array.join(’ ’).split(’ ’)

Paragraphs that do not start with either “born” or “died” can be ignored by the program. How do we test whether a string starts with a certain word? The method 
charAt ↓ can be used to get a specific character from a string. x.charAt(0) gives the first character, 1 is the second one, and so on. One way to check whether a string starts with “born” is:
「born」か「died」で始まらない段落は、プログラムで無視出来ます。どうやって、それらの文字列で始まるかをテスト出来るのでしょうか? charAtメソッドは、文字列から特定の文字を得るのに使うことができます。x.charAt(0)は最初の文字、1は2つめの文字...、というふうに。文字列が「born」で始まるかチェックするための一つの方法です。
paragraph = ’born 15-11-2003 (mother Spot): White Fang’
show paragraph.charAt(0) == ’b’ &&
     paragraph.charAt(1) == ’o’ &&
     paragraph.charAt(2) == ’r’ &&
     paragraph.charAt(3) == ’n’
But that gets a bit clumsy — imagine checking for a word of ten characters. There is something to be learned here though: when a line gets ridiculously long, it can be spread over multiple lines. The result can be made easier to read by lining up the start of the new line with the first element on the original line that plays a similar role. You can also end a line with \ to indicate that it continues on the next line.
ですが、ちょっと面倒です — 10文字の単語でチェックすることを想像して下さい。ここで、ひとつ覚えておくことがあります。もし一行があまりに長いと、複数行にまたがってしまいます。その場合は、元の行の同じような役割をする要素と次の行の始まりを揃えると、(プログラムが)読みやすくなります。また、行末に\を置くことでも、次の行に続くことを示せます。
Strings also have a method called slice . It copies out a piece of the string, starting from the character at the position given by the first argument, and ending before (not including) the character at the position given by the second one. It is the same as using a range as an index. This allows the check to be written in a shorter way.
文字列には、sliceというメソッドもあります。こちらは、最初の引数で与えられた位置から、二つ目の引数で与えられた位置の前まで、文字列の一部のコピーを返します。インデックスとして範囲を使う場合と同じです。これだと、さっきの文字列チェックが、もっと短い書き方で出来るようになります。
show paragraph.slice(0, 4) == ’born’
show paragraph[0...4] == ’born’

Exercise 13
Write a function called startsWith that takes two arguments, both strings. It returns true when the first argument starts with the characters in the second argument, and false otherwise.
練習問題13
二つの文字列を引数に取る、startsWithと呼ばれる関数を書きましょう。この関数は、第一引数が第二引数の文字列で始まる場合に、trueを返し、そうでなければfalseを返します。
 Solution
startsWith = (string, pattern) ->
  string.slice(0, pattern.length) == pattern
# or
startsWith = (string, pattern) ->
  string[0...pattern.length] == pattern
show startsWith ’rotation’, ’rot’


What happens when charAt , slice or a range are used to take a piece of a string that does not exist? Will the startsWith still work when the pattern is longer than the string it is matched against?
charAt、sliceあるいは範囲指定で、存在しない文字列を指定してしまったら何が起きるのでしょう? パターンがマッチさせる文字列より長い場合も、startsWithは動くのでしょうか?
show ’Pip’.charAt 250
show ’Nop’.slice 1, 10
show ’Pin’[1...10]
charAt will return ’’ when there is no character at the given position, and slice or the range will simply leave out the part of the new string that does not exist.
与えられた位置に文字が無い場合、charAtは「」を返します。sliceや範囲指定の場合は単純に存在する部分だけで、新しい文字列を返します。
So yes, startsWith should work. When startsWith(’Idiots’, ’Most honoured colleagues’) is called, the call to slice will, because string does not have enough characters, always return a string that is shorter than pattern . Because of that, the comparison with == will return false , which is correct.
そう、startsWithはちゃんと動くはずです。もし、startsWith(’Idiots’, ’Most honoured colleagues’)のように呼出されれば、文字列は十分な文字数がないので、sliceが呼ばれたとしても、常に(検索)パターンより短い文字列を返すでしょう。そのため、==による比較では正しい答え—falseが返されることになります。
It helps to always take a moment to consider abnormal (but valid) inputs for a program. These are usually called corner cases↓, and it is very common for programs that work perfectly on all the ‘normal’ inputs to screw up on corner cases  [P]  .
プログラムに、普通じゃない(けど、正しい)入力がある場合を、ちょっと考えてみるというのは常に有益です。それらは、よく「コーナーケース(=めったに発生しない厄介なケース)」と呼ばれ、普通の入力に対して完璧に動くプログラムが、コーナーケースで失敗するというのは極めてよくあることです。
○•○
The only part of the cat-problem that is still unsolved is the extraction of names from a paragraph. The algorithm was this:
Find the colon in the paragraph.
Take the part after this colon.
Split this part into separate names by looking for commas.

猫問題に残った未解決部分は、(猫の)名前を段落から抽出する不分です。アルゴリズムはこうです。
段落の中のコロンを見つける
コロンの後の部分を取得
カンマを探して、この部分を複数の名前に分ける

This has to happen both for paragraphs that start with ’died’ , and paragraphs that start with ’born’ . It would be a good idea to put it into a function, so that the two pieces of code that handle these different kinds of paragraphs can both use it.
これは「died」ではじまる段落、「born」で始まる段落の両方でする必要があります。異なる段落を扱う二つのコードのそれぞれから使えるように、一つの関数にまとめるのが良さそうです。

Exercise 14
Can you write a function catNames that takes a paragraph as an argument and returns an array of names?
段落を引数にとって、猫の名前を返す関数catNamesを書けますか?
Strings have an indexOf ↓ method that can be used to find the (first) position of a character or sub-string within that string. Also, when slice is given only one argument, it will return the part of the string from the given position all the way to the end. With a range either the start or end can be left out: ’shorthand’[...5]  ⇒  ’short’ and ’shorthand’[5...]  ⇒  ’hand’ .
文字列はindexOfメソッド持っています。これは文字あるいはその文字列の部分文字列(sub-string)の現れる(最初の)位置を見つけるのに使うことができます。また、sliceに引数がひとつだけ与えられた場合、与えられた位置から最後までの部分を返します。範囲指定では、始めか終わりを書かないでおくことができます。’shorthand’[...5]  なら  ’short’ に。そして、 ’shorthand’[5...]  なら  ’hand’となります。
It can be helpful to use CoffeeScript interactively to ‘explore’ functions. Try ’foo: bar’.indexOf(’:’) and see what you get.
CoffeeScriptをインタラクティブに使って関数を「探検」すると良いですよ。’foo: bar’.indexOf(’:’)を試して、何が得られるか見てみましょう。
Solution
catNames = (paragraph) ->
  colon = paragraph.indexOf ’:’
  paragraph[colon+2...].split ’, ’
​
show catNames ’born 20/09/2004 (mother Yellow Bess): ’ +
              ’Doctor Hobbles the 2nd, Noog’
The tricky part, which the original description of the algorithm ignored, is dealing with spaces after the colon and the commas. The + 2 used when slicing the string is needed to leave out the colon itself and the space after it. The argument to split contains both a comma and a space, because that is what the names are really separated by, rather than just a comma.
This function does not do any checking for problems. We assume, in this case, that the input is always correct.



All that remains now is putting the pieces together. One way to do that looks like this:
今残っているのは、ここまでのピースをまとめあげることだけです。ひとつのやり方としては、こんな感じになるでしょう:

mailArchive = (require ’./04-emails’).retrieveMails()
livingCats = ’Spot’: true
​
for email, i in mailArchive
  paragraphs = email.split ’\n’
  for paragraph in paragraphs
    if startsWith paragraph, ’born’
      names = catNames paragraph
      for name in names
        livingCats[name] = true
    else if startsWith paragraph, ’died’
      names = catNames paragraph
      for name in names
        delete livingCats[name]
​
show livingCats
That is quite a big dense chunk of code. We will look into making it a bit lighter in a moment. But first let us look at our results. We know how to check whether a specific cat survives:
だいぶぎゅむっとした感じのコードですね。この後、これをもう少し軽くする方法を見ていきます。が、ひとまずはその結果を見てみましょう。ある猫が生きているかどうかを確認するやり方は分かっています:
if ’Spot’ in livingCats
  show ’Spot lives!’
else
  show ’Good old Spot, may she rest in peace.’
But how do we list all the cats that are alive? The of ↓ keyword is somewhat similar to the in keyword when it is used together with for :
しかし、どうやったら生きている全ての猫を一覧に出来るのでしょうか? 「of」キーワードは「for」と一緒に使うときは、「in」キーワードにいくらか似ています:

for cat of livingCats
  show cat
A loop like that will go over the names of the properties in an object, which allows us to enumerate all the names in our set.
このような繰返しはオブジェクトのプロパティの名前を調べて行って、集合にある全ての名前を列挙することができます。
○•○
Some pieces of code look like an impenetrable jungle. The example solution to the cat problem suffers from this. One way to make some light shine through it is to just add some strategic blank lines. This makes it look better, but does not really solve the problem.
コードが、足の踏み込めないジャングルのように見えることもあります。猫の問題の解決例は、そうなってしまっています。一定のルールで空行を追加するだけで、その状況から少し見通しを良くすることができます。これは、若干よくなったように見えますが、本当に問題を解決した訳ではありません。
What is needed here is to break the code up. We already wrote two helper functions, startsWith and catNames , which both take care of a small, understandable part of the problem. Let us continue doing this.
ここで必要なのは、コードをバラバラにすることです。すでに、二つのヘルパー関数startsWithとcatNamesを書きましたが、どちらも小さな理解可能な部分を扱うものでした。このやり方を続けてみましょう。

addToSet = (set, values) ->
  for i in [0..values.length]
    set[values[i]] = true
​
removeFromSet = (set, values) ->
  for i in [0..values.length]
    delete set[values[i]]
These two functions take care of the adding and removing of names from the set. That already cuts out the two most inner loops from the solution:
これらの二つの関数は、集合からの名前の追加と削除を扱います。これで、すでに二つの内部ループのほとんどを、解法から取り去ります。

livingCats = ’Spot’: true
​
for email in mailArchive
  paragraphs = email.split ’\n’
  for paragraph in paragraphs
    if startsWith paragraph, ’born’
      addToSet livingCats, catNames paragraph
    else if startsWith paragraph, ’died’
      removeFromSet livingCats, catNames paragraph
​
show livingCats
Quite an improvement, if I may say so myself.
かなりの改善です、我ながら。
Why do addToSet and removeFromSet take the set as an argument? They could use the variable livingCats directly, if they wanted to. The reason is that this way they are not completely tied to our current problem. If addToSet directly changed livingCats , it would have to be called addCatsToCatSet , or something similar. The way it is now, it is a more generally useful tool.
addToSetとremoveFromSetはなぜ、集合を引数にとるのでしょうか? これらの関数は、必要があればlivingCats変数を直接使えるはずです。その理由は、今の問題に完全に特化したものにしていないからです。もし、addToSetが直接livingCatsを変更してしまったら、それはadCatsToCatSetとでも呼ぶべきものです。ここでは、もう少し汎用的で便利なツールにしています。
Even if we are never going to use these functions for anything else, which is quite probable, it is useful to write them like this. Because they are ‘self sufficient’, they can be read and understood on their own, without needing to know about some external variable called livingCats .
もし、他の用途にこの関数をまったく使わないつもりなら、あまり意味はありませんが、こんな風に書いておくとこと便利です。外部の変数であるlivingCatsのことを知らなくても、これらは「自己完結」しているため、読みやすく分かり易いのです。
The functions are not pure: They change the object passed as their set argument. This makes them slightly trickier than real pure functions, but still a lot less confusing than functions that run amok and change any value or variable they please.
この関数はset引数として渡したオブジェクトを変更してしまうため、純関数ではありません。このことが、ちゃんとした純関数と比べると若干トリッキーなものにしてしまってはいますが、自制心を失って所構わず変数や値を変更してしまうような関数などに比べたら、全然ややこしくありません。
○•○
We continue breaking the algorithm into pieces:
アルゴリズムを部分に分けて行く作業を続けましょう:

findLivingCats = ->
  mailArchive = (require ’./04-emails’).retrieveMails()
  livingCats = ’Spot’: true
​
  handleParagraph = (paragraph) ->
    if startsWith paragraph, ’born’
      addToSet livingCats, catNames paragraph
    else if startsWith paragraph, ’died’
      removeFromSet livingCats, catNames paragraph
​
  for email in mailArchive
    paragraphs = email.split ’\n’
    for paragraph in paragraphs
      handleParagraph paragraph
​
  livingCats
​
howMany = 0
for cat of findLivingCats()
  howMany++
show ’There are ’ + howMany + ’ cats.’
The whole algorithm is now encapsulated by a function. This means that it does not leave a mess after it runs: livingCats is now a local variable in the function, instead of a top-level one, so it only exists while the function runs. The code that needs this set can call findLivingCats and use the value it returns.
全てのあるゴリズが、関数によってカプセル化されました。これは、処理が終わった後に余計なものを残さないことを意味します: livingCatsはトップレベルではなく、関数内のローカル変数となったので、関数が実行される間だけ存在します。この集合を必要とするコードは、findLivingCatsを呼んで、そこで返される値を使うことができます。
It seemed to me that making handleParagraph a separate function also cleared things up. But this one is so closely tied to the cat-algorithm that it is meaningless in any other situation. On top of that, it needs access to the livingCats variable. Thus, it is a perfect candidate to be a function-inside-a-function. When it lives inside findLivingCats , it is clear that it is only relevant there, and it has access to the variables of its parent function.
handleParagraphに処理を分けて関数にすると、分かり易くなるように思います。ただ、この関数は猫アルゴリズムに非常に強く結びついているので、他のシチュエーションで使ってもあまり意味がありません。加えて、livingCsats変数にアクセスする必要がああります。そのため、関数内関数にしてしまうのが最適な候補となります。findLivingCatsの中であれば、その場所だけで有効なことが明らかで、親関数の変数にもアクセスすることができる訳です。
This solution is actually bigger than the previous one. Still, it is tidier and I hope you will agree that it is easier to read.
この解決法は、実際のところ前のものより大きいです。ですが、整然としていますし、こちらの方が読みやすいということに、あなたも賛成してくれると期待します。
○•○
The program still ignores a lot of the information that is contained in the e-mails. There are birth-dates, dates of death, and the names of mothers in there.
このプログラムは、まだEメールに含まれるいろいろな情報を無視しています。誕生日や、亡くなった日、そこにある母親たちの名前などがあります。.

To start with the dates: What would be a good way to store a date? We could make an object with three properties, year , month , and day , and store numbers in them.
日付情報から始めましょう : 日付を記録しておくのに良い方法はなんでしょうか? year、month、dayの三つのプロパティを持つオブジェクトを作って、そこに数字を保存しておくことは可能です。

whenWasIt = year: 1980, month: 2, day: 1
But CoffeeScript already provides a kind of object for this purpose. Such an object can be created by using the keyword new ↓:
ですが、CoffeeScriptはすでにこの目的で使うためのオブジェクトが用意されています。newキーワードを使うと、そんなオブジェクトを作成できます。

whenWasIt = new Date 1980, 1, 1
show whenWasIt
Just like the notation with colons and optional braces we have already seen, new is a way to create object values. Instead of specifying all the property names and values, a function is used to build up the object. This makes it possible to define a kind of standard procedure for creating objects. Functions like this are called constructors↓, and in Object Orientation↓ we will see how to write them.
既に見てきたコロンと括弧(あっても無くてもOK)の表記と同じように、newはオブジェクト値を生成するための方法です。全てのプロパティ名と値を指定する代わりに、関数がオブジェクトを作り上げてくれます。これによって、一種の標準的なオブジェクト生成の手順を決めておくことが出来るようになります。こういった関数はコンストラクタと呼ばれ、「オブジェクト指向」の章でどのように書くかを見ることになります。
The Date ↓ constructor can be used in different ways.

show new Date
show new Date 1980, 1, 1
show new Date 2007, 2, 30, 8, 20, 30
As you can see, these objects can store a time of day as well as a date. When not given any arguments, an object representing the current time and date is created. Arguments can be given to ask for a specific date and time. The order of the arguments is year, month, day, hour, minute, second, milliseconds. These last four are optional, they become 0 when not given.
見たままですが、これらのオブジェクトは、日付と同様に、一日の中の時間を保存することができます。もし、引数が何も与えられなければ、現在の時刻と日付を表現するオブジェクトが生成されます。特定の日付や時間にするように、引数を与えることも可能です。引数の順番は、年、月、日、時、分、秒、ミリ秒です。最後の4つの引数はオプションで、指定しなかった場合はそれぞれ0がセットされます。
The month numbers these objects use go from 0 to 11, which can be confusing. Especially since day numbers do start from 1.
これらのオブジェクトで使う「月」番号は、紛らわしいことに0から11です。とくに「日」番号は1から始まるので。
○•○
The content of a Date object can be inspected with a number of get... methods.
Dateオブジェクトの中身は、get...メソッドで調べることができます。

today = new Date();
show "Year: #{today.getFullYear()}
 month: #{today.getMonth()}
 day: #{today.getDate()}"
show "Hour: #{today.getHours()}

 minutes: #{today.getMinutes()}
 seconds: #{today.getSeconds()}"
show "Day of week: #{today.getDay()}"
All of these, except for getDay , also have a set... variant that can be used to change the value of the date object.
getDay以外は、日付オブジェクトの値を変更するために使うset...関数もあります。
Inside the object, a date is represented by the amount of milliseconds it is away from January 1st 1970. You can imagine this is quite a large number.
オブジェクトの中で、日付は1970年1月1日からミリ秒でどれだけ経っているかで表現されています。かなり大きな数になることは想像がつくと思います。

today = new Date()
show today.getTime()
A very useful thing to do with dates is comparing them.
日付オブジェクトで非常に便利なのは、これらの比較です。

wallFall = new Date 1989, 10, 9
gulfWarOne = new Date 1990, 6, 2
show wallFall < gulfWarOne
show wallFall == wallFall
# but
show wallFall == new Date 1989, 10, 9
Comparing dates with < , >, <= , and >= does exactly what you would expect. When a date object is compared to itself with == the result is true , which is also good. But when == ↓ is used to compare a date object to a different, equal date object, we get false . Huh?
「<」と「>」、「<=」と「>=」で日付を比較すると、想像通りのことができます。そのオブジェクト自身と「==」で比較すると、trueが返るのも良いですね。しかし、「==」が異なる日付オブジェクトで、同じ日時を表すオブジェクトの比較に使われた場合、falseか返ってきてしまいます。あれっ?
As mentioned earlier, == will return false when comparing two different objects, even if they contain the same properties. This is a bit clumsy and error-prone here, since one would expect >= and == to behave in a more or less similar way. Testing whether two dates are equal can be done like this:
「==」について前に述べたように、2つのことなるオブジェクトについて比較をすると、「==」はfalseを返します。「>=」と「==」は同じような振る舞いをすると思うでしょうから、ここではちょっと気が利かないというか、間違いのもとですね。二つの日付が同じかどうかをテストするには、次のようにします:

wallFall1 = new Date 1989, 10, 9
wallFall2 = new Date 1989, 10, 9
show wallFall1.getTime() == wallFall2.getTime()
○•○
In addition to a date and time, Date objects also contain information about a timezone↓. When it is one o’clock in Amsterdam, it can, depending on the time of year, be noon in London, and seven in the morning in New York. Such times can only be compared when you take their time zones into account. The getTimezoneOffset ↓ function of a Date can be used to find out how many minutes it differs from GMT (Greenwich Mean Time).
日付と時刻に加えて、Dateオブジェクトはタイムゾーンについての情報を含んでいます。アムステルダムで1時なら、時季によりますが、ロンドンでは正午、ニューヨークでは朝の7時のはずです。こうした時間は、タイムゾーンを考慮して初めて比較することができます。DateオブジェクトのgetTimezoneOffset関数は何分GMT(グリニッジ標準時)からずれているかを調べるのに使うことができます。

now = new Date()
show now.getTimezoneOffset()
Exercise 15
’died 27/04/2006: Black Leclère’ The date part is always in the exact same place of a paragraph. How convenient. Write a function extractDate that takes such a paragraph as its argument, extracts the date, and returns it as a date object.
日付部分は、いつも段落の全く同じ場所にあります。何て便利。このような段落を引数にとって、日付を取り出し、日付オブジェクトとして返すextractDate関数を書きなさい。
 
Solution
extractDate = (paragraph) ->
  numberAt = (start, length) ->
    Number paragraph[start...start + length]
  new Date numberAt(11, 4),     # Year
           numberAt( 8, 2) - 1, # Month
           numberAt( 5, 2)      # Day
​
show extractDate ’died 27-04-2006: Black Leclère’
It would work without the calls to Number , but as mentioned earlier, I prefer not to use strings as if they are numbers. The inner function was introduced to prevent having to repeat the Number and slice part three times.
Note the -1 for the month number. Like most people, Aunt Emily counts her months from 1, so we have to adjust the value before giving it to the Date constructor. (The day number does not have this problem, since Date objects count days in the usual human way.)
In Regular Expressions↓ we will see a more practical and robust way of extracting pieces from strings that have a fixed structure.


Storing cats will work differently from now on. Instead of just putting the value true into the set, we store an object with information about the cat. When a cat dies, we do not remove it from the set, we just add a property death to the object to store the date on which the creature died.
これから、猫情報の保存は違った方法をとります。ただ、trueを集合に入れておくのではなくて、猫に関する情報と一緒に保存します。猫がもし死んでいたら、それを削除するのではなくて、創造物が死んだ日をオブジェクトに記録するため、deathプロパティを追加します。

This means our addToSet and removeFromSet functions have become useless. Something similar is needed, but it must also store birth-dates and, later, the mother’s name.
これは、addToSetとremoveFromSet関数が用済みになることを意味します。同様のものが改めて必要になりますが、それは、産まれた日と母猫の名前も保存出来るものでなくてはなりません。
catRecord = (name, birthdate, mother) ->
  name:   name
  birth:  birthdate
  mother: mother
​
addCats = (set, names, birthdate, mother) ->
  for name in names
    set[name] = catRecord name, birthdate, mother
​
deadCats = (set, names, deathdate) ->
  for name in names
    set[name].death = deathdate
catRecord is a separate function for creating these storage objects. It might be useful in other situations, such as creating the object for Spot. ‘Record’ is a term often used for objects like this, which are used to group a limited number of values.
catRecordは
○•○
So let us try to extract the names of the mother cats from the paragraphs.

’born 15/11/2003 (mother Spot): White Fang’
One way to do this would be…

extractMother = (paragraph) ->
  start = paragraph.indexOf ’(mother ’
  start += ’(mother ’.length
  end = paragraph.indexOf ’)’
  paragraph[start...end]
​
show extractMother \
  ’born 15/11/2003 (mother Spot): White Fang’
Notice how the start position has to be adjusted for the length of the string ’(mother ’ , because indexOf returns the position of the start of the pattern, not its end.

Exercise 16
The thing that extractMother does can be expressed in a more general way. Write a function between that takes three arguments, all of which are strings. It will return the part of the first argument that occurs between the patterns given by the second and the third arguments. That is:
between ’born 15/11/2003 (mother Spot): White Fang’,
         ’(mother ’, ’)’  ⇒  ’Spot’
between ’bu ] boo [ bah ] gzz’, ’[ ’, ’ ]’  ⇒  ’bah’

To make that second test work, it can be useful to know that indexOf can be given a second, optional parameter that specifies at which point it should start searching.
 Solution
between = (string, start, end) ->
  startAt = string.indexOf start
  startAt += start.length
  endAt = string.indexOf end, startAt
  string[startAt...endAt]
show between ’bu ] boo [ bah ] gzz’, ’[ ’, ’ ]’



Having between makes it possible to express extractMother in a simpler way:
extractMother = (paragraph) ->  between paragraph, ’(mother ’, ’)’

○•○
The new, improved cat-algorithm looks like this:

findCats = ->
  mailArchive = (require ’./04-emails’).retrieveMails()
  cats = {’Spot’: catRecord ’Spot’,
    new Date(1997, 2, 5), ’unknown’}
​
  handleParagraph = (paragraph) ->
    if startsWith paragraph, ’born’
      addCats cats, catNames(paragraph),
              extractDate(paragraph),
              extractMother(paragraph)
    else if startsWith paragraph, ’died’
      deadCats cats, catNames(paragraph),
               extractDate(paragraph)
​
  for email in mailArchive
    paragraphs = email.split ’\n’
    for paragraph in paragraphs
      handleParagraph paragraph
  cats
​
catData = findCats()
show catData
Having that extra data allows us to finally have a clue about the cats aunt Emily talks about. A function like this could be useful:

formatDate = (date) -> "#{date.getDate()}/" +
                       "#{date.getMonth() + 1}/" +
                       "#{date.getFullYear()}"
catInfo = (data, name) ->
  unless name of data
    return "No cat by the name of #{name} is known."
  cat = data[name]
  message = "#{name}," +
            " born #{formatDate cat.birth}" +
            " from mother #{cat.mother}"
  if "death" of cat
    message += ", died #{formatDate cat.death}"
  "#{message}."
​
show catInfo catData, "Fat Igor"
The return statement in catInfo is used as an escape hatch. If there is no data about the given cat, the rest of the function is meaningless, so we immediately return a value, which prevents the rest of the code from running.

In the past, certain groups of programmers considered functions that contain multiple return statements sinful. The idea was that this made it hard to see which code was executed and which code was not. Other techniques, which will be discussed in Error Handling↓, have made the reasons behind this idea more or less obsolete, but you might still occasionally come across someone who will criticise the use of ‘shortcut’ return statements.

Exercise 17
The formatDate function used by catInfo does not add a zero before the month and the day part when these are only one digit long. Write a new version that does this.
Solution
formatDate = (date) ->
  pad = (number) ->
    if number < 10
      "0" + number
    else
      number
  "#{pad date.getDate()}/" +
  "#{pad date.getMonth() + 1}/" +
  "#{date.getFullYear()}"
​
show formatDate new Date 2000, 0, 1



↓↓The property ‘dot’ accessor that we have been using comes in a handy form combined with the existential operator. Instead of object.element we can write object?.element if object is defined then we get the value as before. But if it is null then we get undefined instead of an error.

Exercise 18
Write a function oldestCat which, given an object containing cats as its argument, returns the name of the oldest living cat.

 Solution
oldestCat = (data) ->
  oldest = null
  for name of data
    cat = data[name]
    unless ’death’ of cat
      if oldest is null or oldest.birth > cat.birth
        oldest = cat
  oldest?.name
show oldestCat catData
The conditions in the unless/if statements might seem a little intimidating. It can be read as ‘only store the current cat in the variable oldest if it is not dead, and oldest is either null or a cat that was born after the current cat’.

for cat, info of catData # Test with dead cats
  delete catData[cat] unless ’death’ of info
show oldestCat catData
Note that this function returns undefined when there are no living cats in data . What does your solution do in that case?



Now that we are familiar with arrays, I can show you something related. Whenever a function is called, a special variable named arguments ↓ is added to the environment in which the function body runs. This variable refers to an object that resembles an array. It has a property 0 for the first argument, 1 for the second, and so on for every argument the function was given. It also has a length ↓ property.
This object is not a real array though, it does not have methods like push , and it does not automatically update its length property when you add something to it. Why not, I never really found out, but this is something one needs to be aware of.

argumentCounter = ->
  show "You gave me #{arguments.length} arguments."
​
argumentCounter "Death", "Famine", "Pestilence"
 
Some functions can take any number of arguments. These typically loop over the values in the arguments object to do something with them. We can create a print function that uses show to print each of its arguments.

print = -> show arg for arg in arguments
​
print ’From here to’, 1/0
Others can take optional arguments which, when not given by the caller, get some sensible default value.

add = (number, howmuch) ->
  if  arguments.length < 2
    howmuch = 1
  number + howmuch
​
show add 6
show add 6, 4
Exercise 19
Extend the range function from the exercise on page 1↑ to take a second, optional argument. If only one argument is given, it behaves as earlier and produces a range from 0 to the given number. If two arguments are given, the first indicates the start of the range, the second the end.
Solution
range = (start, end) ->
  if arguments.length < 2
    end = start
    start = 0
  result = []
  for i in [start..end]
    result.push i
  result
​
show range 4
show range 2, 4
 
The optional argument does not work precisely like the one in the add example above. When it is not given, the first argument takes the role of end , and start becomes 0 .



CoffeeScript has a few of features that can make it simpler to work with arguments. You can set default values directly in the argument list. The showfunction is defined like:

show = (obj, depth = 2, showHidden = false,
             colors = useColors) ->
  # body
When the arguments starting from depth are not present in a call, they get the value after the = . No checks are needed in the body where the arguments are used.
For variable arguments you can use ... commonly called splats. The ellipsis can indicate extra arguments in a function definition or a call. Do you remember the testPure function? It was used with both absolute which takes one argument and power which takes two. In its definition (c, a...) says that a... is a variable argument list. The variable arguments are used two times, in the call to func and in the call to property .

prelude.qc.testPure = (func, types, name, property) ->
  prelude.qc.declare name, types, (c, a...) ->
    c.assert property c, a..., c.note func a...
Finally the or= operator can be used in options or= defaults as shorthand for options || (options = defaults) .

Exercise 20
You may remember this line of code from the introduction:
show sum [1..10] All we need to make this line work is a sum function. This function takes an array of numbers, and returns their sum. Write it, it should be easy. Check that it also works with range .
 
Solution
sum = (numbers) ->
  total = 0
  for num in numbers
    total += num
  total
​
show sum [1..10]
show sum range 1, 10


The previous chapter showed the functions Math.max and Math.min . With what you know now, you will notice that these are really the properties max and min of the object stored under the name Math ↓. This is another role that objects can play: A warehouse holding a number of related values.
There are quite a lot of values inside Math , if they would all have been placed directly into the global environment they would, as it is called, pollute it. The more names have been taken, the more likely one is to accidentally overwrite the value of some variable. For example, it is not a far shot to want to name something max .
Most languages will stop you, or at least warn you, when you are defining a variable with a name that is already taken. Not JavaScript.
In any case, one can find a whole outfit of mathematical functions and constants inside Math . All the trigonometric functions are there — cos , sin , tan , acos , asin , atan . π and e, which are written with all capital letters (PI and E ), which was, at one time, a fashionable way to indicate something is a constant. pow is a good replacement for the power functions we have been writing, it also accepts negative and fractional exponents. sqrt takes square roots. max and min can give the maximum or minimum of two values. round ↓, floor ↓, and ceil ↓ will round numbers to the closest whole number, the whole number below it, and the whole number above it respectively.
There are a number of other values in Math , but this text is an introduction, not a reference↓. References are what you look at when you suspect something exists in the language, but need to find out what it is called or how it worked exactly. A useful reference for predefined global objects like the Math object exist at the Mozilla Developer Network.
 
An interesting object is Array when you look through its reference notice that many definitions for example forEach are marked
Requires JavaScript 1.6
or another version number. JavaScript 1.5 corresponds to ECMA-262 3rd Edition from December 1999.
More than a decade later this is still the standard that most JavaScript engines implement — including V8, the engine that via JavaScript compiles CoffeeScript to native machine code. It is fair to say that JavaScript is evolving at a glacial pace. Fortunately CoffeeScript and Underscore leapfrogs the JavaScript process and gives you language and library advances that you can use without waiting for existing browsers and engines to be upgraded.
○•○
Maybe you already thought of a way to find out what is available in the Math object:

for name of Math
  show name
But alas, nothing appears. Similarly, when you do this:

for name of [’Huey’, ’Dewey’, ’Loui’]
  show name
You only see 0 , 1 , and 2 , not length , or push , or join , which are definitely also in there. Apparently, some properties of objects are hidden↓. There is a good reason for this: All objects have a few methods, for example toString ↓, which converts the object into some kind of relevant string, and you do not want to see those when you are, for example, looking for the cats that you stored in the object.
Why the properties of Math are hidden is unclear to me. Someone probably wanted it to be a mysterious kind of object. But you can peek under the hood with show — see the prelude for details:

show Math, 2, true
show [’Huey’, ’Dewey’, ’Loui’], 2, true
All properties your programs add to objects are visible. There is no way to make them hidden, which is unfortunate because, as we will see in Object Orientation↓, it would be nice to be able to add methods to objects without having them show up in our for / of loops.
○•○
↓Some properties are read-only, you can get their value but not change it. For example, the properties of a string value are all read-only.
↓Other properties can be ‘watched’. Changing them causes things to happen. For example, lowering the length of an array causes excess elements to be discarded:

array = [’Heaven’, ’Earth’, ’Man’]
array.length = 2
show array


##<a name = エラー処理>"エラー処理"</a>

Kazuki Suda  ■main translater
Takashi Tsuda ■main translater

Takaichi Qubo
Takahiro Yoshida

Writing programs that work when everything goes as expected is a good
start. Making your programs behave properly when encountering unexpected
conditions is where it really gets challenging.
The problematic situations that a program can encounter fall into two categories:
Programmer mistakes and genuine problems. If someone forgets
to pass a required argument to a function, that is an example of the first
kind of problem. On the other hand, if a program asks the user to enter a
name and it gets back an empty string, that is something the programmer
can not prevent.
In general, one deals with programmer errors by finding and fixing them,
and with genuine errors by having the code check for them and perform
some suitable action to remedy them (for example, asking for the name
again), or at least fail in a well-defined and clean way.

全てが予定通りに（なった時に）動作するプログラムを書くのは良いことです。予期せぬ事態に遭遇した時に正しく動作するプログラムを作成する場面こそ、本当の実力が試されるでしょう。
プログラムが遭遇しうる問題のある状況は、２つのカテゴリ：プログラマのミスと正真正銘の問題に分類されます。もし関数に必要な引数を渡し忘れた場合は、第一の例にあたります。一方で、ユーザーに名前を求めて空の文字列が返ってきたような場合、それを防ぐことは出来ません。
一般的に、プログラマーエラーは見つけて修正するしかありません。正真正銘のエラーの場合、コードをチェックし問題解決に関して何らかの解決手段（たとえば再度名前を入力させるなど）を講じましょう。または、少なくともエラーを防げないとしても正しい方法で終わりましょう。

　　 ○●○

It is important to decide into which of these categories a certain problem falls. 
For example, consider our old power function:

power = (base, exponent) ->
result = 1
for count in [0..exponent]
result *= base
result

これらのカテゴリでどちらかの問題に陥ったかを決めることは重要です。例えば、前のpower関数で考えてみましょう。

When some geek tries to call power 'Rabbit', 4, that is quite obviously a programmer error, but how about power 9, 0.5? The function can not handle fractional exponents, but, mathematically speaking, raising a number to the ½ power is perfectly reasonable (Math.pow can handle it). In
situations where it is not entirely clear what kind of input a function accepts,it is often a good idea to explicitly state the kind of arguments that are acceptable in a comment.

何人かのギークがpower ‘Rabbit’,4 と読びだそうとすると、これは明らかにプログラマーエラーとなりますが、power 9,0.5で はどうでしょうか？この関数は小数の指数を扱うことは出来ませんが、1/2乗という表現で数学的には問題ありません。（Math.powはそれを扱うことが出来ます）。関数がどの入力を受け入れるのかはっきりしない状況では、明示的なコメントの中に許容される引数の種類を明記することをお勧めします。

　　 ○●○

If a function encounters a problem that it can not solve itself, what should it do? In Data Structures we wrote the function between:

between = (string , start, end) ->
startAt = string.indexOf start
startAt += start.length
endAt = string.indexOf end, startAt
string[startAt...endAt]

関数がそれ自体を解決できないという問題に遭遇した場合、何をすべきでしょうか？DataStructures　で、between関数を書きました。

If the given start and end do not occur in the string, indexOf will return -1 and this version of between will return a lot of nonsense:
between('Your mother!', '{-', '-}') returns 'our mother'. 
When the program is running, and the function is called like that, the code
that called it will get a string value, as it expected, and happily continue doing something with it. But the value is wrong, so whatever it ends up doing with it will also be wrong. And if you are unlucky, this wrongness only causes a problem after having passed through twenty other functions.
In cases like that, it is extremely hard to find out where the problem started.
In some cases, you will be so unconcerned about these problems that you do not mind the function misbehaving when given incorrect input. For example, if you know for sure the function will only be called from a few places, and you can prove that these places give it decent input, it is generally not worth the trouble to make the function bigger and uglier so that it can handle problematic cases.
But most of the time, functions that fail ‘silently’ are hard to use, and even dangerous. What if the code calling between wants to know whether everything went well? At the moment, it can not tell, except by re-doing all the work that between did and checking the result of between with its own result. That is bad. One solution is to make between return a special value, such as false or undefined, when it fails.

与えられたstartとendがstringの中に現れなければ、indexOf は-1を返し、betweenは全く意味不明な戻り値を返します。
between('Your mother!', '{-', '-}') は 'our mother'を戻します。
プログラムが実行され、関数がそのように呼び出された場合、呼び出されたコードは期待通りのStringの値を得て、めでたく処理を継続することが出来ます。しかし値は間違っており、それは更に間違った状態で終わります。また、運が悪ければ、この誤りは20の他の関数を通過した後に問題を引き起こします。そのようなケースでは、問題が発生した場所を見つけるのは非常に困難です。
時には、不正な値が与えられ関数の誤動作に気が付くまで、これらの問題に対して無関心になるかもしれません。関数がほんの数か所からしか呼び出されていなのが確かであり、呼び出し元が適切な入力を与えていると証明できる場合、一般的には、関数を肥大化させ醜くする必要はありません。
しかし、ほとんどの場合、表面化されず失敗した関数は、扱い辛く、そしてさらに厄介です。betweenの呼び出し元のコードが全てが上手くいったかどうか知りたい場合にはどのようにすれば良いでしょうか？
現時点では、betweenの全ての動作を再実行するか自分自身の結果とbetweenの結果をチェックしなければ、知ることは出来ません。それは良くないです。それが失敗した時、falseまたはundefinedのような特別な値をbetweenに返すことが一つの解決策になります。

between = (string , start, end) ->
startAt = string.indexOf start
if startAt == -1 then return
startAt += start.length
endAt = string.indexOf end, startAt
if endAt == -1 then return
string[startAt...endAt]

You can see that error checking does not generally make functions prettier.
But now code that calls between can do something like:

エラーチェックが通常の関数よりも見にくくなることが解ります。しかし今回呼び出すコードは次のことを行うことが出来ます。

prompt "Tell me something", "", (answer) ->
parenthesized = between answer , "(", ")"
if parenthesized?
show "You parenthesized '#{parenthesized}'."

　 ○●○

In many cases returning a special value is a perfectly fine way to indicate an error. It does, however, have its downsides. Firstly, what if the function can already return every possible kind of value? For example, consider this function that gets the last element from an array:

エラーを示す為に特別の値を返すことは、多くの場合、非常におススメです。しかしながらそれはマイナス面を持っています。最初に、関数が可能な限り全ての値を戻すことが出来たらどうでしょうか？例えば、配列の最後の要素を取り出すこの関数を考えてみましょう。

lastElement = (array) ->
if array.length > 0
array[array.length - 1]
else
undefined
show lastElement [1, 2, undefined]

So did the array have a last element? Looking at the value lastElement returns, it is impossible to say.
The second issue with returning special values is that it can sometimes lead to a whole lot of clutter. If a piece of code calls between ten times, it has to check ten times whether undefined was returned. Also, if a function calls between but does not have a strategy to recover from a failure, it will have to check the return value of between, and if it is undefined, this function can then return undefined or some other special value to its caller, who in turn also checks for this value.
Sometimes, when something strange occurs, it would be practical to just stop doing what we are doing and immediately jump back to a place that knows how to handle the problem.
Well, we are in luck, a lot of programming languages provide such a thing. Usually, it is called exception handling.

arrayは最後の要素を持っているでしょうか？lastElement の戻り値を見ると、言うまでもありません。
特別な値を返す2つめの問題は、それが非常に多くの混乱に結びつく場合があるということです。コードが10回 between を呼び出す場合、それはundefined が返されたかどうか10回チェックする必要があります。また、between 関数が失敗から回復する手段を持たない場合、bettweenの戻り値をチェックしなければなりません、そしてそれがundefinedの場合、この関数は、 undefined または特別な値を返すことが出来ますが、呼び出し元は更にその値をチェックすることになります。
時々、奇妙なことが起こりますがその際は、今行っている処理を中断して、その問題の解決法を知っている場所へ直ちに戻ることが現実的でしょう。さて、幸運なことに、多くのプログラミング言語では、そのようなものを提供しています。たいてい、それらは例外処理と呼ばれます。

　 ○●○

The theory behind exception handling goes like this: It is possible for code to raise (or throw) an exception, which is a value. Raising an exception somewhat resembles a super-charged return from a function — it does not just jump out of the current function, but also out of its callers, all the way up to the top-level call that started the current execution. This is called unwinding the stack. You may remember the stack of function calls that was mentioned in Functions. An exception zooms down this stack, throwing away all the call contexts it encounters.

If they always zoomed right down to the base of the stack, exceptions would not be of much use, they would just provide a novel way to blow up your program. Fortunately, it is possible to set obstacles for exceptions along the stack. These ‘catch’ the exception as it is zooming down, and can do something with it, after which the program continues running at the point where the exception was caught. An example:

例外処理の支える考え方は次の通りです。コードは例外を発生（または投げる）することが出来ます。例外とは、一つの値として扱います。例外を発生されることは、関数からの凄い戻り方（super-charged return）に多少似ています。
- それはちょうど、現在の関数から抜け出すだけではなく、プログラムを実行したトップレベルの呼び出しまで戻ります。これはスタックのアンワインドと呼ばれています。
例外は、途中のコールコンテキストを全て無視して、スタックを一気に遡ってゆきます。

これらは常にスタックのベースに直ちに一気に遡ってゆくのであれあば、例外というものは利用価値はありません。それは、プログラムをぶち壊す新しい手段にすぎません。
幸運なことに、このスタックを任意の場所で止めることが可能です。
一気に遡っていく例外を「キャッチ」し、何らかの対処を行った上で、キャッチした箇所から処理を再開してゆくことができるのです。例：


lastElement = (array) ->
   if  array. length  >  0
      array[array.length  -  1]
   else
       throw ‘Can not take the last element’  +
                  ‘   of  an  empty  array  .’

lastElementPlusTen  =  (array)  -  >
   lastElement(array)  +  10


try
  show lastElementPlusten  []
catch  error
   show  ‘Something went wrong:  ‘  +  error

- 98 -
#<a name = "パラダイム">パラダイム</a>

Functional Programming
 
##<a name = "関数型プログラミング">関数型プログラミング</a>
 
As programs get bigger, they also become more complex and harder to understand. We all think ourselves pretty clever, of course, but we are mere human beings, and even a moderate amount of chaos tends to baffle us. And then it all goes downhill. Working on something you do not really understand is a bit like cutting random wires on those time-activated bombs they always have in movies. If you are lucky, you might get the right one - especially if you are the hero of the movie and strike a suitably dramatic pose - but there is always the possibility of blowing everything up.
 
コードの量が増えるにつれ、プログラムはより複雑に、分かりにくくなってゆきます。いくら自分で賢いと思っていても、私たちは所詮、人間というちっぽけな生き物に過ぎません。わずかな矛盾に直面しただけで頭を抱え、事態は一層複雑さを増してゆくのみでしょう。十分な理解無く物事に取り組むのは、映画でよくあるように時限爆弾のコードを当てずっぽうに切断するのと大差ありません。映画の主人公であればクールに時限爆弾を解除できるかもしれませんが、物事はそううまくは運びません。下手したら大爆発を引き起こすケースもありますからね。
 
Admittedly, in most cases, breaking a program does not cause any large explosions. But when a program, by someone’s ignorant tinkering, has degenerated into a ramshackle mass of errors, reshaping it into something sensible is a terrible labour - sometimes you might just as well start over.
 
もちろん、プログラムを破壊して大爆発が起こるようなことは「まず」ありません。しかし誰かが考えなしにプログラムをいじって、エラーだらけのハチャメチャな状態にしてしまった場合、それをまともな状態に復旧させるのは至難の業です。あるいは最初から作り直したほうがまだましかも知れません。
 
Thus, the programmer is always looking for ways to keep the complexity of his programs as low as possible. An important way to do this is to try and make code more abstract. When writing a program, it is easy to get sidetracked into small details at every point. You come across some little issue, and you deal with it, and then proceed to the next little problem, and so on. This makes the code read like a grandmother’s tale.
 
それゆえプログラマは、コードを可能な限りシンプルに保つ方法を常に模索しているのです。重要なプラクティスとしては、より抽象的なコーディングを目指し、実践することです。プログラムを書く際、その都度些細なディテールにとらわれ、本質から逸脱してしまうことはよくあります。小さな問題にぶつかり、それを処理した後に別の小さな問題にぶつかる。これの繰り返しです。そのおかげで、年寄りの長話のようなコードになってしまうのです。
 
Yes, dear, to make pea soup you will need split peas, the dry kind. And you have to soak them at least for a night, or you will have to cook them for hours and hours. I remember one time, when my dull son tried to make pea soup. Would you be- lieve he hadn’t soaked the peas? We almost broke our teeth, all of us. Anyway, when you have soaked the peas, and you’ll want about a cup of them per person, and pay attention be- cause they will expand a bit while they are soaking, so if you aren’t careful they will spill out of whatever you use to hold them, so also use plenty water to soak in, but as I said, about a cup of them, when they are dry, and after they are soaked you cook them in four cups of water per cup of dry peas.
 
いいこと？エンドウ豆のスープを作るときは、まずスプリットピーを用意しなさい。乾燥したエンドウ豆のことよ。それを必ず一晩は水に浸しておくこと。じゃないと調理するのに何時間かかるか分かったものじゃないわ。そうそう！昔、おっちょこちょいの息子がエンドウ豆スープを作ろうとしたことがあってね、あの子ったらエンドウ豆を水に浸しておかなかったの、信じられる？私たちみんな、歯が折れちゃうかと思ったくらいよ。あら、こんな話をしてる場合じゃなかったわね。それでエンドウ豆を水に浸すんだけど、一人前でカップ一杯分必要よ。水に漬けるとエンドウ豆は少し膨れるから分量には気を付けなさい。うっかりしてると、容器からこぼれちゃうわよ。たっぷりの水で浸しておきなさい。どれだけのエンドウ豆を浸すかって言うと、さっき言ったとおり、カップ一杯分よ。乾燥状態のエンドウ豆をね。それで水に浸してから、カップ一杯分の分量につき4カップの水で調理するの。
 
- 99 -
 
you cook them in four cups of water per cup of dry peas. Let it simmer for two hours, which means you cover it and keep it barely cooking, and then add some diced onions, sliced celery stalk, and maybe a carrot or two and some ham. Let it all cook for a few minutes more, and it is ready to eat.
 
２時間くらいコトコト煮込こみなさい。フタをしてそのまま放っておくだけ。その後角切りにした玉ねぎ、スライスしたセロリを入れるの。あと１～２本のニンジンとかハムとかを入れるのもいいわね。さああと何分か煮込んだら、もう出来上がりよ！
 
Another way to describe this recipe:
 
さて、このレシピを次のように言い換えてみましょう。
 
Per person: one cup dried split peas, half a chopped onion, half a carrot, a celery stalk, and optionally ham.
 
一人前：乾燥スプリットピー1カップ、玉ねぎのみじん切り（１／２個）、ニンジン（１／２本）、セロリのスライス、お好みでハムなど。
 
Soak peas overnight, simmer them for two hours in four cups of water (per person), add vegetables and ham, and cook for ten more minutes.
 
一晩水に浸したエンドウ豆を、一人前につき４カップの水で２時間煮込みます。それから野菜やハムを加え、さらに１０分間調理します。
 
This is shorter, but if you do not know how to soak peas you will surely screw up and put them in too little water. But how to soak peas can be looked up, and that is the trick. If you assume a certain basic knowledge in the audience, you can talk in a language that deals with bigger concepts, and express things in a much shorter and clearer way.
 
このレシピはより簡潔になっていますが、もし作り手がエンドウ豆の浸し方を知らない場合、浸しておく水が少なすぎて失敗するのは目に見えています。しかしエンドウ豆の浸し方は別に調べれば済みますし、そこがミソとなるのです。聞き手がある予備知識を共有している場合、話し手はより大きな文脈で会話ができ、また物事をより簡潔にかつ明確に表現することができます。
 
This, more or less, is what abstraction is.
 
これはまさに、抽象化のプロセスとも言えるのではないでしょうか。
 
How is this far-fetched recipe story relevant to programming? Well, obviously, the recipe is the program. Furthermore, the basic knowledge that the cook is supposed to have corresponds to the functions and other constructs that are available to the programmer. If you remember the introduction of this book, things like while make it easier to build loops, and in Data Structures we wrote some simple functions in order to make other functions shorter and more straightforward. Such tools, some of them made available by the language itself, others built by the programmer, are used to reduce the amount of uninteresting details in the rest of the program, and thus make that program easier to work with.
 
しかしこのやや強引とも言えるレシピのエピソードは、プログラミングと何の関係があるのでしょう？すでにお分かりのことと思いますが、レシピとはプログラムのことです。もっと言えば、料理が前提とする基礎知識は、プログラマが利用できる関数やその他の構成要素に相当します。本書の導入部分で紹介したwhileなどを使えばループ処理が簡単になりますし、データ構造では簡単な関数を用いて、他の関数をコンパクトに、より分かりやすいものにしています。これらの機能は、言語そのものが提供しているものもあれば、プログラマ自身が実装することもあります。プログラムから非本質的な細部を削り、扱いやすくするために利用します。
 
○●○
 
Functional programming, which is the subject of this chapter, produces abstraction through clever ways of combining functions. A programmer armed with a repertoire of fundamental functions and, more importantly, the knowledge on how to use them, is much more effective than one who starts from scratch. Unfortunately, a standard CoffeeScript environment comes with deplorably few essential functions, so we have to write them ourselves or, which is often preferable, make use of somebody else’s code (more on that in Modularity).
 
本章のテーマである関数型プログラミングは、関数を効果的に組み合わせることにより抽象化を実現します。プログラマは、幾つかの基本的な関数、さらにはそれらを利用するためのノウハウを身に付けていれば、何の知識もない状態から始める場合に比べて、圧倒的に効率的なプログラミングが可能になります。しかし残念なことに、標準的なCoffeeScript環境には、必須とも言える関数はほとんど実装されていません。それらは自分たちで用意するか、あるいはもう少しまともな選択肢として、誰か他の開発者のコードを利用することをお勧めします。詳しくはモジュール性をご参照下さい。
 
- 100 -
 
In this chapter we write a set of useful functions to understand how they work and solve problems with them to understand how to use them. In later chapters we will use the larger set of functions in the Underscore library that comes with CoffeeScript.
 
この章では便利な関数を幾つか書いてゆき、それらがどのように作用してどのように問題を解決するのかを通して、利用法を理解してゆきます。本章以降は、ＣｏｆｆｅｅＳｃｒｉｐｔに付属のＵｎｄｅｒｓｃｏｒｅライブラリに収められている、より多くの関数群を扱ってゆきます。
 
There are other popular approaches to abstraction, most notably object-oriented programming, the subject of Object Orientation.
 
抽象化の方法としては、他にも有力な候補があります。最も特筆すべきはオブジェクト指向プログラミングです。詳しくはオブジェクト指向で述べられています。
 
○●○
 
In programming a fundamental operation is performing an action on every element of an array. Many programming languages have borrowed their way of doing this from the C programming language:
 
プログラミングで、配列内の各要素に対して、基本的な操作を行いたい場合があります。多くのプログラミング言語は、Ｃ言語のやり方を真似てこれを実現しています。
 
size_t i;
size_t N = sizeof(thing) / sizeof(thing[0]);
for (i = 0; i < N; ++i) {
do_something(thing[i]);
}
 
That is very ugly, an eyesore if you have any good taste at all. It has been improved somewhat in derived languages like C++ and JavaScript. Other programming languages can have very different approaches17. In CoffeeScript it becomes the reasonably pleasant:
 
まともな感覚を持っている者であれば、これは非常に醜い代物に見えることでしょう。C++やJavaScriptなどのCから派生した言語においては、もう少しましな書き方になります。他のプログラミング言語では、かなり異なった手法を採用しています17。例えばCoffeeScriptでは、このくらい分かりやすくなっています。
 
for i in [0...thing.length] then doSomething thing[i]
# or
# あるいは
for element in thing then doSomething element
 
Still do we have to do this over and over or can it be abstracted? The problem is that, whereas most functions just take some values, com- bine them, and return something, such a loop contains a piece of code that it must execute. It is easy to write a function that goes over an array and prints out every element:
 
しかし、この表現にしても面倒な繰り返し表記は残っています。このプロセスを抽象化することは可能でしょうか？これを考える上で厄介な問題があります。それは、ほとんどの関数が「簡単な引数を取り、それらを組み合わせて、何かを返す」というシンプルな形を取っているのに対して、今述べたようなループには「実行すべきコードそのもの」が含まれているということです。配列を受け取って、各要素を出力する関数を書くのは簡単です。
 
printArray = (array) ->
for element in array
show element
return
 
 
 
17 In Mathematica a function can be set as listable - eliminating the need for a loop:
 
17 Mathematicaでは関数はリスタブルとして定義でき、繰り返し処理の記述を省ことができます。
 
f[x_] := If[x > 0, Sqrt[x], Sqrt[-x]]; SetAttributes[f, Listable];
 
- 101 -
 
But what if we want to do something else than print? Since ‘doing something’ can be represented as a function, and functions are also values, we can pass our action as a function value:
 
ここで、出力以外のことをしたくなった場合はどうすればいいでしょうか？実は「何かを行う」ということは関数として表現可能であり、かつ関数そのものも値として扱えるため、その「何かを行う」関数自身を別の関数に引数として渡すことができるのです。
 
forEach = (array, action) ->
for element in array
action element
#return
forEach ['Wampeter', 'Foma', 'Granfalloon'], show
 
In CoffeeScript most statements are expressions that return a value, that is also the case with the for statement. A return statement at the end of forEach will make it return undefined. Here forEach is allowed to return its value, when we get to the map function you will see why.
 
CoffeeScriptでは、ほとんどの命令文の正体は値を返す式ですが、それはfor構文にも当てはまります。最後にreturn文があれば、forEachはundefinedを返します。ここではforEachはその値を返しています。何故そうするのかは、map関数を使う際に明らかになります。
 
By making use of an anonymous function, something just like a for loop can be written as:
 
匿名関数を利用すれば、forループのようなものは次のように書くことができます。
 
sum = (numbers) ->
total = 0
forEach numbers, (number) -> total += number
total
show sum [1, 10, 100]
 
Note that the variable total is visible inside the anonymous function because of the scoping rules. Also note that this version is hardly shorter than the for loop.
 
スコープ規則により、変数totalは匿名関数内でアクセス可能です。また、このバージョンは、forループと比べてもコードの長さはほとんど変わりません。
 
You do get a variable bound to the current element in the array, number, so there is no need to use numbers[i] anymore, and when this array is created by evaluating some expression, there is no need to store it in a variable, because it can be passed to forEach directly.
 
配列内の要素が変数numberに格納されているため、numbers[i]などのような表記は不要です。また何かの処理の結果として配列が生成さされる場合でも、forEachにそれを直接渡すことで、わざわざ変数に代入する手間を省くことができます。
 
The cat-code in Data Structures contains a piece like this:               	
 
データ構造のcat-codeには、このようなコードがありました。
 
paragraphs = email.split '\n'
for paragraph in paragraphs
handleParagraph paragraph
 
This can now be written as…
 
これをこのように書き換えることができます。
 
forEach email.split('\n'), handleParagraph
 
On the whole, using more abstract (or ‘higher level’) constructs results in more information and less noise: The code in sum reads ‘for each number in numbers add that number to the total’, instead of… ‘there is this
 
一般的に言えば、抽象的な、あるいは「高次な」構造を利用すれば、より密な情報量でノイズの少ないコードを書くことができます。sum関数のコードは、「配列numbers内の個々の要素をnumberとして取り出し、その値をtotalに加えてゆく」と読むことができます。元々のコードの
 
- 102 -
 
‘there is this variable that starts at zero, and it counts upward to the length of the array called numbers, and for every value of this variable we look up the corresponding element in the array and add this to the total’
 
「ある変数があります。この変数を、0から配列numbersの長さまで数えてゆくわけですが、カウントアップの際に配列内の対応する位置にある要素を参照して、その値をtotalに加えてゆく」と比べてみてください。
 
○●○
 
What forEach does is take an algorithm, in this case ‘going over an array’, and abstract it. The ‘gaps’ in the algorithm, in this case, what to do for each of these elements, are filled by functions which are passed to the algorithm function.
 
forEachの真髄は、「配列を走査する」というアルゴリズムを抽象化することにあります。「配列内の各要素に対して何を行うか」という肝心のアルゴリズムの「中身」は、forEach関数に引数として渡される関数が実現してくれます。
 
Functions that operate on other functions are called higher-order functions. By operating on functions, they can talk about actions on a whole new level. The makeAddFunction function from Functions is also a higherorder function. Instead of taking a function value as an argument, it produces a new function. Higher-order functions can be used to generalise many algorithms that regular functions can not easily describe. When you have a repertoire of these functions at your disposal, it can help you think about your code in a clearer way: Instead of a messy set of variables and loops, you can decompose algorithms into a combination of a few fundamental algorithms, which are invoked by name, and do not have to be typed out again and again.
 
他の関数上で作用する関数のことを、高階関数と呼びます。関数が関数を処理するという視点は、物事の処理に関して全く新しい地平を切り開いてくれます。関数で紹介されていたmakeAddFunctionも、高階関数の一つです。この場合関数を引数に取る代わりに、関数を戻り値として返します。高階関数なら、通常の関数で実現の難しい多くのアルゴリズムを記述することが可能です。これらの関数を身につけ自在に操ることができれば、より分かりやすいコーディングを行う手助けとなるでしょう。ごちゃごちゃした変数やループを使うのではなく、問題のアルゴリズムを幾つかの本質的なアルゴリズムの組み合わせに分割し、各々を必要に応じて呼び出すことによって、同じコードを何度も打ち込む手間が省けます。
 
Being able to write what we want to do instead of how we do it means we are working at a higher level of abstraction. In practice, this means shorter, clearer, and more pleasant code.
 
「どのように実行するか」ではなく「何を実行するか」を書くことは、作業をより高度な抽象度にまで高めてくれます。それはより短く明確で、かつ快適なコーディングを保証します。
 
○●○
 
Another useful type of higher-order function modifies the function value it is given:
 
また別の使い方として、高階関数は、引数として与えられた関数をカスタマイズすることもできます。
 
negate = (func) ->
(x) -> not func x
isNotNaN = negate isNaN
show isNotNaN NaN
 
The function returned by negate feeds the argument it is given to the original function func, and then negates the result. But what if the function you want to negate takes more than one argument? You can get access to any arguments passed to a function with the arguments array, but how
 
negateが返す関数は、元々のfunc関数に引数を与えて、その結果に対して否定演算を行います。ここで、否定演算を適用したい関数が、二つ以上の引数をとる場合はどうしたらいいでしょうか？
 
- 103 -
 
You can get access to any arguments passed to a function with the arguments array, but how do you call a function when you do not know how many arguments you have?
 
関数に渡した引数はargumentsという配列から取得することはできますが、引数が幾つ必要であるか分からない場合、どのようにして関数を呼び出せばよいでしょうか？
 
Functions18 have a method called apply, which is used for situations like this. It takes two arguments. The role of the first argument will be discussed in Object Orientation, for now we just use null there. The second argument is an array containing the arguments that the function must be applied to. Now you know the underlying arguments mechanism remember that you can also use splats…
 
関数オブジェクト18はapplyと呼ばれる関数を持っており、これは次のような場合に用います。まずapply関数は二つの引数を取ります。1番目の引数に関しては、オブジェクト指向の説明をご覧下さい。ここではシンプルにnullを使います。2番目の引数には、対象の関数が必要とする引数を配列として入れます。ここでunderlying argumentsを使うこともできますし、スプラット（…）を使うこともできます。
 
show Math.min.apply null, [5, 6]
negate = (func) ->
-> not func.apply null, arguments
negate = (func) ->
(args...) -> not func args...
 
○●○
 
Let us look at a few more basic algorithms related to arrays. The sum function is really a variant of an algorithm which is usually called reduce or foldl:
 
配列に関して、基本的なアルゴリズムをもう少し紹介したいと思います。実はsum関数は、一般的にreduceやfoldLと呼ばれるものの一例に過ぎません。
 
reduce = (array, combine, base) ->
forEach array, (element) ->
base = combine base, element
base
add = (a, b) -> a + b
sum = (numbers) -> reduce numbers, add, 0
show sum [1, 10, 100]
 
reduce combines an array into a single value by repeatedly using a function that combines an element of the array with a base value. This is exactly what sum did, so it can be made shorter by using reduce… except that addition is an operator and not a function in CoffeeScript, so we first had to put it into a function.
 
reduceは、ベースとなる値を用意し、それに対して配列内の個々の要素を結合することによって、配列を一つの値へと集約します。これはsumの働きと全く同じです。従ってreduce…を用いてsumをコンパクトに改良することができます。ただCoffeeScriptでは加算は関数ではなく演算子ですから、まず加算を関数で定義する必要があります。
 
 
 
18 Unfortunately, on at least older versions of the Internet Explorer browser a lot of built-in functions, such as alert, are not really functions… or something. They report their type as 'object' when given to the typeof operator, and they do not have an apply method. Your own functions do not suffer from this, they are always real functions.
 
18残念ながら、少なくとも古いバージョンのInternet Explorerにおいては、alertなどの多くのビルトイン関数は、実際には関数としては実装されていません。typeof演算子を使った場合、これらの「関数」は”object”を返します。またこれらはapply関数を持ちません。一方、自分で作成した関数は問題ありません。それらは本当の意味での関数となります。
 
- 104 -
 
Exercise 21
練習問題21
 
Write a function countZeroes, which takes an array of numbers as its argument and returns the amount of zeroes that occur in it. Use reduce.
 
number型の配列を引数に取り、その中に出現する0の数を数える、countZeros関数を作ってください。ただし、その際reduceを使ってください。
 
Then, write the higher-order function count, which takes an array and a test function as arguments, and returns the amount of elements in the array for which the test function returned true. Re-implement countZeroes using this function.
 
そして、配列とテスト関数を引数に取り、配列の要素のうちテスト関数がtrueを返すものの数を数える高階関数countを作ってください。また、この関数を用いてcountZerosを再実装してください。
 
Solution
解答
 
countZeroes = (array) ->
counter = (total, element) ->
total++ if element is 0
total
reduce array, counter, 0
bits = [1, 0, 1, 0, 0, 1, 1, 1, 0]
show countZeroes bits
 
Here is the solution that uses a count function, with a function that produces equality-testers included to make the final countZeroes function even shorter:
 
こちらはcount関数を使った解になります。等価性の評価関数を返す関数を利用することで、最終的なcountZeroes関数をさらに短いものにしています。
 
count = (test, array) ->
reduce array, ((total, element) ->
total + if test element then 1 else 0), 0
equals = (x) ->
(element) -> x == element
countZeroes = (array) ->
count equals(0), array
show countZeroes bits
 
One other generally useful ‘fundamental algorithm’ related to arrays is called map.
 
配列を扱う際に様々な用途に役立つ「基本的アルゴリズム」をもう一つ紹介しましょう。それはmapです。
 
- 105 -
 
called map. It goes over an array, applying a function to every element, just like forEach. But instead of discarding the values returned by function, it builds up a new array from these values.
 
mapはforEachと同様に、配列内の各要素に対して関数を適用します。しかし関数の戻り値を破棄するのではなく、その戻り値から新たな配列を作り出すのです。
 
map = (array, func) ->
result = []
forEach array, (element) ->
result.push func element
result
show map [0.01, 2, 9.89, Math.PI], Math.round
 
Note that the last argument is called func, not function, this is because function is a keyword and thus not a valid variable name. And then:
 
ちなみにfunctionは予約語ですので、変数名としては使えません。従って最後の引数はfuncとしています。さらに続けて、
 
# Leave out result since forEach already returns it
# forEach自体が戻り値を返しているので、resultを省略します
map = (array, func) ->
forEach array, (element) ->
func element
# Leave out func arguments
# 引数のfuncを省略します
map = (array, func) ->
forEach array, func
# Leave out forEach arguments
# forEachの引数を省略します
map = forEach
 
The reduction shows how nicely functions and expressions can be used to shorten a function. If we were concerned with the performance of forEach then inserting a return at the end of its definition would prevent it from collecting the results of the for comprehension and we would have to provide an implementation in map.
 
この一連のプロセスから分かるとおり、複数の関数や表現式をうまく使うことで、一つの関数をコンパクトにまとめることができます。forEachのパフォーマンスが気になるようであれば、定義の最後にreturnを挿入してみましょう。そうすればfor内包表記の計算結果は保存されません。ただしその場合、mapの実装を別に行わなければいけません。
 
○●○
 
There once was, living in the deep mountain forests of Transylvania, a recluse. Most of the time, he just wandered around his mountain, talking to trees and laughing with birds. But now and then, when the pouring rain trapped him in his little hut, and the howling wind made him feel unbearably small, the recluse felt an urge to write something, wanted to pour some thoughts out onto paper, where they could maybe grow bigger than he himself was.
 
むかしむかし、トランシルバニアの山林の奥深く、一人の世捨て人がいました。いつも山中を気ままに歩き、木々に語りかけ、鳥たちとともに笑いあう、そんな生活を送っていました。ある日のことでした。大雨のせいで小さな掘っ立て小屋から出ることができず、おまけにビュービュー吹きすさぶ風の音のせいで、彼は自分がひどくちっぽけな存在になってしまったような気がしました。彼はとにかく何か物を書きたい、取り留めない考え事を紙に綴ってゆけば、こんな惨めな思いから抜け出せるのでは、と思いました。
 
- 106 -
 
After failing miserably at poetry, fiction, and philosophy, the recluse finally decided to write a technical book. In his youth, he had done some computer programming, and he figured that if he could just write a good book about that, fame and recognition would surely follow.
 
詩を書いたり、小説や哲学にも手を出しましたがどれもうまくいきません。世捨て人はついに、一冊の技術書を書くことを決意しました。彼は若い頃にプログラミングの経験があったのです。その時のことをうまく本にできれば、きっと人から評価され、名声を得られることでしょう。
 
So he wrote. At first he used fragments of tree bark, but that turned out not to be very practical. He went down to the nearest village and bought himself a laptop computer. After a few chapters, he realised he wanted to put the book in HTML format, in order to put it on his web-page…
 
そうして彼は書き始めました。最初は木の皮に書いていたのですが、これはあまり現実的ではないことに気づいたようです。それで近くの村に下り、一台のノートパソコンを買ったのです。何章か書き進めた後に、彼は本をHTMLフォーマットにして、ウェブサイトに公開したいと考えるようになりました。
 
Are you familiar with HTML? It is the method used to add mark-up to pages on the web, and we will be using it a few times in this book, so it would be nice if you know how it works, at least generally. If you are a good student, you could go search the web for a good introduction to HTML now, and come back here when you have read it. Most of you probably are lousy students, so I will just give a short explanation and hope it is enough.
 
話は中断しますが、HTMLはご存知でしょうか？HTMLとはウェブページにマークアップを記述する言語のことです。この本にもHTMLは使われていますし、HTMLがどのようなものなのかは、知っておいて損は無いはずです。優秀な生徒であれば、すぐにでもHTMLについて分かりやすく説明したウェブサイトをインターネットでHTMLについて調べ、理解してくれることでしょう。しかしながら大半の優秀ではない学生たちのために、さしあたってHTMLについて簡単な説明をしてゆきます。
 
HTML stands for ‘HyperText Mark-up Language’. An HTML document is all text. Because it must be able to express the structure of this text, information about which text is a heading, which text is purple, and so on, a few characters have a special meaning, somewhat like backslashes in CoffeeScript strings. The ‘less than’ and ‘greater than’ characters are used to create ‘tags’. A tag gives extra information about the text in the document. It can stand on its own, for example to mark the place where a
 
HTMLとは、ハイパーテキストマークアップ ランゲージの略です。HTMLドキュメントは、テキストで書かれています。どのテキストが見出しでどのテキストが紫色かなどの情報―すなわちテキストの構造―を記述するため、幾つかの文字は特別な意味を持っています。CoffeeScriptの文字列におけるバックスラッシュのようなものです。「大なり」と「小なり」の記号が、「タグ」を形成します。タグとは、ドキュメント内のテキストに対して追加の情報を賦与します。
 
- 107 -
 
It can stand on its own, for example to mark the place where a picture should appear in the page, or it can contain text and other tags, for example when it marks the start and end of a paragraph.
 
タグは、ページに表示する画像の位置を指定する時のようにそれ自体完結した要素として扱えますし、あるいは段落の始まりと終わりを示す時のように、テキストや他のタグを内部に含むこともできます。
 
Some tags are compulsory, a whole HTML document must always be contained in between html tags. The HTML version is specified on the first line with the document type, DOCTYPE, so browsers can parse and render it correctly. Here is an example of an HTML5 document:
 
また、幾つかのタグは必須タグです。HTMLドキュメントは、htmlタグの中に書かなければいけません。HTMLのバージョンは、最初の一行目にドキュメントタイプ、すなわちDOCTYPEに指定します。ブラウザはこれを見て、正しくドキュメントを解析しレンダリングを行うわけです。以下はHTML5ドキュメントの例になります。
 
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8"/>
<title>A quote</title>
<title>引用</title>
</head>
<body>
<h1>A quote</h1>
<h1>引用</h1>
<blockquote>
<p>The connection between the language in which we
think/program and the problems and solutions we can
imagine is very close. For this reason restricting
language features with the intent of eliminating
programmer errors is at best dangerous.</p>
 
<p>我々がプログラミングを行う時に用いる言語と、我々が考えうる問題及びその解法との間は、非常に密接な関係がある。この理由によって、プログラマからエラーを取り除くために言語機能に制限を設けることは、ひいき目に見ても危険であると言える。</p>
 
<p>-- Bjarne Stroustrup</p>
<p>-- ビャーネ・ストロヴストルップ</p>
</blockquote>
<p>Mr. Stroustrup is the inventor of the C++
programming language, but quite an insightful
person nevertheless.</p>
 
<p>ストロヴストルップ氏はC++プログラミング言語の開発者はでありますが、それにもかかわらず深い洞察力を持った方です。</p>
 
<p>Also, here is a picture of an ostrich:</p>
 
<p>そしてこちらがダチョウの写真になります：</p>
 
<img src="../img/ostrich.jpg"/>
</body>
</html>
 
Elements that contain text or other tags are first opened with <tagname>, and afterwards finished with </tagname>. The html element always contains two children: head and body. The first contains information about the document, the second contains the actual document.
 
テキストや他のタグを内部に含んだタグは、<タグ名>で始まり、</タグ名>で終わります。HTML要素は、必ず二つの子要素を持ちます。それはheadとbodyです。headにはドキュメントの情報が含まれており、bodyには実際のドキュメントが含まれています。
 
Most tag names are cryptic abbreviations. h1 stands for ‘heading 1’, the biggest kind of heading. There are also h2 to h6 for successively smaller headings. p means ‘paragraph’, and img stands for ‘image’. The img element does not contain any text or other tags, but it does have some extra information, src="../img/ostrich.png", which is called an ‘attribute’. In this case, it contains information about the image file that should be shown here.
 
ほとんどのタグ名は、やや分かりにくい省略形となっています。h1は「見出し１(=heading 1)」を意味します。これは一番大きな見出しです。見出しは他にもh2からh6まで揃っており、数値が大きいほど小さな見出しになります。pは「段落(=paragraph)」を意味し、imgは「画像(=image)」を意味します。img要素は内部にテキストや他のタグを含むことはありませんが、src=”…/img/ostrich.png”のような追加情報を持っています。これは「属性」と呼びます。ここには、表示すべき画像ファイルの情報が書かれています。
 
Because < and > have a special meaning in HTML documents, they can not be written directly in the text of the document.
 
「<」と「>」はHTMLドキュメントにおいて特別な意味を持っているため、ドキュメント内のテキストに直接書くことはできません。
 
- 108 -
 
not be written directly in the text of the document. If you want to say ‘5 < 10’ in an HTML document, you have to write ‘5 &lt; 10’, where ‘lt’ stands for ‘less than’. ‘&gt;’ is used for ‘>’, and because these codes also give the ampersand character a special meaning, a plain ‘&’ is written as ‘&amp;’.
 
例えばドキュメント内で「5 < 10」と書きたい場合、「5 &lt; 10」と書く必要があります。ここでltは「小なり(=less than)」を意味します。そして「&gt;」は「>(=greater than)」を意味します。ここでアンド記号（&）に特別な意味が与えられているため、リテラルの「&」は、「&amp;」と書きます。
 
Now, those are only the bare basics of HTML, but they should be enough to make it through this chapter, and later chapters that deal with HTML documents, without getting entirely confused.
 
今まで述べてきたことは、必要最低限のHTML入門編でしかありません。しかしHTMLドキュメントを扱う本章および次章以降を読み進めてゆく上では、これで十分だと思われます。
 
○●○
 
The prelude has a function viewURL that can be used to look at HTML docu- ments. The example document above is stored in the file '06-Quote.html', so you can view it by executing the following code:
 
preludeには、HTMLドキュメントを表示するための関数viewURLが用意されています。上に挙げたサンプルドキュメントは、「06-Quote.html」に保存されていますので、以下のコードを実行してその内容を表示させてみて下さい。
 
viewURL '06-Quote.html'
 
You can also run a tiny server from your program or the interactive CoffeeScript environment (REPL). It can serve a webpage either from a string variable or from a file. If you have created a web page in a string variable, say stroustrupQuote then you can start the server with:
 
また、プログラムで小さなサーバーを立てたり、インタラクティブなCoffeeScript環境（REPL）を使うことも可能です。それで文字列あるいはファイルからウェブページを表示させることができます。作成したウェブページを、例えばstroustrupQuoteといった変数に格納した場合、次のようにしてサーバーを立ち上げることができます。
 
viewServer stroustrupQuote
 
Or you could give it a filename as its argument. When you are done with the server then you can either type stopServer() or CTRL-C.
 
あるいは、ファイル名を引数として与えても構いません。サーバーを閉じる時は、stopServer()とタイプするか、Ctrl＋Cを押してください。
 
○●○
 
So, picking up the story again, the recluse wanted to have his book in HTML format. At first he just wrote all the tags directly into his manuscript, but typing all those less-than and greater-than signs made his fingers hurt, and he constantly forgot to write &amp; when he needed an &. This gave him a headache. Next, he tried to write the book in Microsoft Word, and then save it as HTML. But the HTML that came out of that was fifteen times bigger and more complicated than it had to be. And besides, Microsoft Word gave him a headache.
 
さて物語を再開しましょう。我らが世捨て人は、自分の本をHTMLフォーマットにしたいと考えています。彼はまず、全てのタグを原稿に直接書いていました。しかし大なり記号小なり記号をいちいちタイピングしてゆくのは、大変な骨折りです。おまけに彼は、アンド記号の必要な箇所に&amp;と書くことをしょっちゅう忘れてしまいます。どうしたらいいものか、彼は頭を抱えて悩み始めました。そこで、次に彼はMicrosoft Wordを使い、原稿をHTMLとして保存してみました。しかし出力されたHTMLは、本来あるべきファイルよりも15倍ほど大きく、複雑なものになってしまいます。さらに悪いことに、Microsoft Wordそのものが使い辛く頭痛の種となってしまいます。
 
The solution that he eventually came up with was this: He would write the book as plain text, following some simple rules about the way paragraphs were separated and the way headings looked. Then, he would write a program to convert this text into precisely the HTML that he wanted.
 
最終的に思いついたソリューションは次の通りです。まず本を飾り気の無い単純なテキストとして書き始めます。しかしそこに、段落の分け方と見出しの付け方に関してシンプルな規則を適用することにしたのです。次に彼は、このテキストを正確にHTMLに変換してくれるプログラムを書きました。
 
The rules are this:
 
規則は、次の通りです。
 
- 109 -
 
1. Paragraphs are separated by blank lines.
1. 各段落は、空行で分けられている
 
2. A paragraph that starts with a ‘%’ symbol is a header. The more ‘%’ symbols, the smaller the header.
2. 「%」記号で始まる段落は、見出しである。「%」記号が多ければ多いほど、見出しは小さくなる。
 
3. Inside paragraphs, pieces of text can be emphasised by putting them between asterisks.
3. 段落中で、アスタリスクに囲まれたテキストは強調表示される
 
4. Footnotes are written between braces.
4. 脚注は、大括弧の間に書く
 
○●○
 
After he had struggled painfully with his book for six months, the recluse had still only finished a few paragraphs. At this point, his hut was struck by lightning, killing him, and forever putting his writing ambitions to rest.
 
6ヶ月にもわたる艱難辛苦に満ちた執筆作業にもかかわらず、世捨て人は、ほんのわずかの段落しか完成させることができていません。掘っ立て小屋は雷に打たれ、彼は大いなる野望を抱えたまま、帰らぬ人となってしまいました。
 
From the charred remains of his laptop, I could recover the following file:
 
こうして黒焦げになったノートパソコンから、私は以下のファイルを復旧させることができました。
 
% The Book of Programming
% プログラミングの本
 
%% The Two Aspects
%%　陰と陽
 
Below the surface of the machine, the program moves.
 
マシンの奥深い場所で、プログラムが動いている。
 
Without effort, it expands and contracts. In great harmony, electrons scatter and regroup. The forms on the monitor are but ripples on the water. The essence stays invisibly below.
 
それはいとも容易く拡大と縮小を繰り広げる。偉大なる調和の元に、電子は離れそして再び集うのだ。モニター上のイメージは、水上のさざなみに如かず。真理は我々の見えないところに存在する。
 
When the creators built the machine, they put in the processor and the memory. From these arise the two aspects of the program.
 
天はPCに、CPUとメモリを与えた。ここからプログラムの陰陽が浮き彫りにされる。
 
The aspect of the processor is the active substance. It is called Control. The aspect of the memory is the passive substance. It is called Data.
 
まずCPUとは、能動的な存在である。これはコントロールと呼ばれる。一方でメモリは、受動的な存在である。これはデータと呼ばれる。
 
Data is made of merely bits, yet it takes complex forms. Control consists only of simple instructions, yet it performs difficult tasks. From the small and trivial, the large and complex arise.
 
データは単純なビットからできているが、複雑な情報の担い手となる。コントロールはシンプルな命令から成り立っているが、それでも難しいタスクを実行することができる。矮小でちっぽけなものから、偉大で複雑なものが生まれるのだ。
 
The program source is Data. Control arises from it. The Control proceeds to create new Data. The one is born from the other, the other is useless without the one. This is the harmonious cycle of Data and Control.
 
プログラムのソースはデータである。コントロールはそこから生じる。コントロールは新しいデータを生成する。一方がもう一方から生まれ、もう一方は一方が存在しないと意味を成さない。これこそがデータとコントロールの調和的な循環である。
 
Of themselves, Data and Control are without structure. The programmers of old moulded their programs out of this raw substance. Over time, the amorphous Data has crystallised
 
データもコントロールも、それ自身は何の構造も持っていない。いにしえのプログラマは、これらの原料を型に流し込むようにプログラムを作り上げていた。
 
- 110 -
 
Over time, the amorphous Data has crystallized into data types, and the chaotic Control was restricted into control structures and functions.
 
時は流れ、無定形のデータはデータ型へと結晶化され、混沌たるコントロールはコントロール構造及び関数へと集約されてゆく。
 
%% Short Sayings
%% 対話
 
When a student asked Fu-Tzu about the nature of the cycle of Data and Control, Fu-Tzu replied 'Think of a compiler, compiling itself.'
 
門人が孔子に、データとコントロールの循環的な性質について問う。孔子これに応えて曰く「コンパイラはどうだい、自分自身をコンパイルしているじゃないか」
 
A student asked 'The programmers of old used only simple machines and no programming languages, yet they made beautiful programs. Why do we use complicated machines and programming languages?'. Fu-Tzu replied 'The builders of old used only sticks and clay, yet they made beautiful huts.'
 
門人が問いて曰く「いにしえのプログラマは、シンプルなマシンしか使わず、プログラミング言語なんてありませんでした。それでも美しいプログラムを書くことができたそうです。ならばどうして私たちに複雑なマシンと複雑なプログラミング言語が必要なのでしょうか？」孔子、これに応えて曰く「そうだね。いにしえの建築家たちは棒切れと粘土しか使わなかったが、それでも美しい掘っ立て小屋を作ることができたがね。」
 
A hermit spent ten years writing a program. 'My program can compute the motion of the stars on a 286-computer running MS DOS', he proudly announced. 'Nobody owns a 286-computer or uses MS DOS anymore.', Fu-Tzu responded.
 
ある隠者が10年かけてプログラムを書き終えた。自らを誇りて曰く「私のプログラムは、MS DOSの動く286マシンで、天体の動きを計算することができる。」孔子、これに応えて曰く「誰も286マシンなんて持っちゃいないし、MS DOSなんて使っちゃいないよ。」
 
Fu-Tzu had written a small program that was full of global state and dubious shortcuts. Reading it, a student asked 'You warned us against these techniques, yet I find them in your program. How can this be?' Fu-Tzu said 'There is no need to fetch a water hose when the house is not on fire.' {This is not to be read as an encouragement of sloppy programming, but rather as a warning against neurotic adherence to rules of thumb.}
 
孔子がグローバル変数や怪しげなショートカットだらけの、小さなプログラムを書き上げた。それを見た門人が問いて曰く「先生は使ってはいけない手法について教えてくれましたよね。それなのに先生のプログラムにはそれらがばっちり使われているじゃないですか。どういうことですか？」孔子、これに応えて曰く「家が燃えていないならば、わざわざ水道ホースを引っ張り出す必要は無いのだよ。」{これは杜撰なプログラミングを勧めるものではない。むしろ原則に固執することの危険性を指摘しているのである。}
 
%% Wisdom
%% 叡智
 
A student was complaining about digital numbers. 'When I take the root of two and then square it again, the result is already inaccurate!'. Overhearing him, Fu-Tzu laughed. 'Here is a sheet of paper. Write down the precise value of the square root of two for me.'
 
門人が、数値に関して愚痴りて曰く「２の平方根を二乗しただけなのに、計算結果が狂っている！」これを聞き孔子、莞爾として笑いて曰く「ここに一枚の紙がある。どうか２の平方根の正確な値を書いてくれないかね。」
 
Fu-Tzu said 'When you cut against the grain of the wood, much strength is needed. When you program against the grain of a problem, much code is needed.'
 
孔子曰く「木理を切る時は、大変な力が必要だ。小さな問題をプログラムで解く時でも、大変な量のコードが必要なのだよ。」
 
Tzu-li and Tzu-ssu were boasting about the size of their latest programs. 'Two-hundred thousand lines', said Tzu-li, 'not counting comments!'. 'Psah', said Tzu-ssu, 'mine is almost a *million* lines already.' Fu-Tzu said 'My best
 
子路と子索が、最近書いたプログラムのサイズで競い合っている。
「俺は20万行書いたぞ！」子路曰く「コメント抜きでだ！」
「ほう」子索曰く「私のは*100万*行を超えたがね。」
 
- 111 -
 
Fu-Tzu said 'My best program has five hundred lines.' Hearing this, Tzu-li and Tzu-ssu were enlightened.
 
孔子曰く「私のベストプログラムは500行だよ。」これを聞き、子路と子索は啓かれる。
 
A student had been sitting motionless behind his computer for hours, frowning darkly. He was trying to write a beautiful solution to a difficult problem, but could not find the right approach. Fu-Tzu hit him on the back of his head and shouted '*Type something!*' The student started writing an ugly solution. After he had finished, he suddenly understood the beautiful solution.
 
門人、眉をしかめてPCの前に座ったまま、数刻微動だにせず。難しい問題を解くために美しいコードを書こうとするも、どうしてもそれを見出せずにいた。孔子が彼の後頭部をたたき、叱り付ける「*とっととコーディングしたまえ！*」門人は汚いコードを書き始める。それを書き上げた時、彼は突如として美しいコードに思い至った。
 
%% Progression
%% 前進
 
A beginning programmer writes his programs like an ant builds her hill, one piece at a time, without thought for the bigger structure. His programs will be like loose sand. They may stand for a while, but growing too big they fall apart{Referring to the danger of internal inconsistency and duplicated structure in unorganised code.}.
 
プログラミング初心者は、まるでアリが塚を築くがごとく、大きな構造を考えずに一気にプログラムを書き始める。そのコードはまるでサラサラの砂のようだ。小さなものならともかく、少し大きなプログラムを組み立てようとすると、たちまち崩れてしまう。{コード内部の一貫性の無さや、重複コードによって生じる危険性を指している}
 
Realising this problem, the programmer will start to spend a lot of time thinking about structure. His programs will be rigidly structured, like rock sculptures. They are solid, but when they must change, violence must be done to them {Referring to the fact that structure tends to put restrictions on the evolution of a program.}.
 
プログラマはこの問題に直面し、構造について多大な時間を費やして考えるようになる。やがてプログラムは、岩彫刻のようにがっしりしたものになってゆく。堅牢なプログラムはしかし、ひとたび変更の必要に迫られたとき、暴力に訴えなければそれを変えることはできない。 {構造そのものが、プログラムの発展を妨げてしまうという傾向を示している}
 
The master programmer knows when to apply structure and when to leave things in their simple form. His programs are like clay, solid yet malleable.
 
真のプログラマは、構造を用いることと単純なコーディングを行うこととのバランス感覚を心得ている。そのプログラムは粘土のように、堅牢かつ柔軟であるのである。
 
%% Language
%% 言語
 
When a programming language is created, it is given syntax and semantics. The syntax describes the form of the program, the semantics describe the function. When the syntax is beautiful and the semantics are clear, the program will be like a stately tree. When the syntax is clumsy and the semantics confusing, the program will be like a bramble bush.
 
プログラミング言語は、シンタクスとセマンティクスを備えたものとして作られた。シンタクスはプログラムの形式を、セマンティクスはその機能をつかさどる。シンタクスが美しくセマンティクスが明確であるならば、プログラムは堂々たる樹木の容をなす。シンタクスが拙く、セマンティクスが混乱していると、プログラムは茨の茂みとなる。
 
Tzu-ssu was asked to write a program in the language called Java, which takes a very primitive approach to functions. Every morning, as he sat down in front of his computer, he started complaining. All day he cursed, blaming the language for all that went wrong. Fu-Tzu
 
子索はJavaと呼ばれる言語でプログラムを書くよう命じられた。Javaは、非常に原始的な関数の使い方を要請する言語である。彼は毎朝PCの前に座っては、文句を言い始める。こいつは全てを滅茶苦茶にしてしまうどうしようもない言語であると、彼は一日中口汚く罵っていた。 
 
- 112 -
 
listened for a while, and then reproached him, saying 'Every language has its own way. Follow its form, do not try to program as if you were using another language.'
 
孔子、これをしばらく聞き、そして彼に近づいて曰く
「どんな言語にもやり方というものがあるのだよ。その形式に従いなさい。決して別の言語を扱うかのごとくプログラムを行ってはいけないよ。」
 
○●○
 
To honour the memory of our good recluse, I would like to finish his HTML-generating program for him. A good approach to this problem goes like this:
 
われらが世捨て人の想いを無駄にしないためにも、ぜひHTML生成プログラムを作ってみましょう。まずこの問題に関して、次のようなアプローチが考えられます。
 
1. Split the file into paragraphs by cutting it at every empty line.
2. Remove the ‘%’ characters from header paragraphs and mark them as headers.
3. Process the text of the paragraphs themselves, splitting them into normal parts, emphasised parts, and footnotes.
4. Move all the footnotes to the bottom of the document, leaving numbers19 in their place.
5. Wrap each piece into the correct HTML tags.
6. Combine everything into a single HTML document.
 
1. ファイルを、空の行で区切って幾つかの段落に分ける
2. ヘッダ行から%記号を取り除き、ヘッダとしてマーキングする
3. 段落内のテキストを処理する。通常部分、強調部分、そして脚注部分へと分割する。
4. 全ての脚注をドキュメントの一番下に移動し、脚注のあった箇所に数字19を入れておく。
5. 各分割部分を正しくHTMLタグでマークアップする
6. 全体を一つのHTMLドキュメントとしてまとめる
 
This approach does not allow footnotes inside emphasised text, or vice versa. This is kind of arbitrary, but helps keep the example code simple.
If, at the end of the chapter, you feel like an extra challenge, you can try to revise the program to support ‘nested’ mark-up.
The whole manuscript is in '06-RecluseFile.text'. You can get it as a string value by calling the readTextFile function in the prelude.
 
ただこの手法では、強調されたテキスト内に脚注を入れることはできませんし、逆もまた無理です。これはやや恣意的なルールですが、代わりにサンプルコードをシンプルにできます。
この章を終えて物足りないと感じるようであれば、ネスト可能なマークアップをサポートするようにプログラムを改良してみてはいかがでしょうか。
原文は「06-RecluseFile.text」に収められています。preludeにあるreadTextFile関数を使って、中身を文字列として取り出してみましょう。
 
recluseFile = readTextFile '06-RecluseFile.text'
 
○●○
 
Step 1 of the algorithm is trivial. A blank line is what you get when you have two newlines in a row, and if you remember the split method that strings have, which we saw in Data Structures, you will realise that this will do the trick:
 
アルゴリズムのステップ１は至極簡単です。空の行は、2つの改行が連続して続いた場合に発生します。ところで、以前データ構造でsplitを使ったのを覚えているでしょうか。この関数を使えばステップ１は簡単に実現できます。
 
paragraphs = recluseFile.split "\n\n"
show "Found #{paragraphs.length} paragraphs."
 
 
 
19 Like this…
19 こんな感じです
 
- 113 -
 
Exercise 22
練習問題22
 
Write a function processParagraph that, when given a paragraph string as its argument, checks whether this paragraph is a header. If it is, it strips of the ‘%’ characters and counts their number. Then, it returns an object with two properties, content, which contains the text inside the paragraph, and type, which contains the tag that this paragraph must be wrapped in, 'p' for regular paragraphs, 'h1' for headers with one ‘%’, and 'hX' for headers with X ‘%’ characters.
 
段落文字列を引数として受け取り、その段落がヘッダかどうかをチェックする関数、processParagraphを作ってみてください。ヘッダの場合、%記号を切り分け、その数を数えてください。それから段落内のテキストを含んだcontentというプロパティ、及び段落をラップするタグを含んだtypeというプロパティ、この2つのプロパティを持ったオブジェクトを返します。ここでtypeには、通常の段落の場合は「p」が入り、%記号が1つの場合は「h1」が入ります。%記号がX個あるのに対して、typeの値は「hX」となります。
 
Solution
解答
 
processParagraph = (paragraph) ->
header = 0
while paragraph[0] == '%'
paragraph = paragraph.slice 1
header++
type: if header == 0 then 'p' else 'h' + header,
content: paragraph
 
show processParagraph paragraphs[0]
 
This is where we can try out the map function we saw earlier.
 
ここで、先ほど紹介したmap関数を試すときが来ました。
 
paragraphs = map recluseFile.split('\n\n'),
processParagraph
show paragraphs[0..2]
 
And bang, we have an array of nicely categorised paragraph objects. We are getting ahead of ourselves though, we forgot step 3 of the algorithm:
 
さあ、これで綺麗に分類された段落オブジェクトのできあがりです。この調子でアルゴリズムその3に進んでゆきましょう。
 
Process the text of the paragraphs themselves, splitting them into normal parts, emphasised parts, and footnotes.
段落内のテキストを処理する。通常部分、強調部分、そして脚注部分へと分割する
 
Which can be decomposed into:
 
この処理は、次のように分解可能です：
 
1. If the paragraph starts with an asterisk, take off the emphasised part and store it.
2. If the paragraph starts with an opening brace, take off the footnote and store it.
 
1. 段落がアスタリスクで始まっている場合、強調部分を取り出し、保存します。
2. 段落が開き中括弧で始まっている場合、脚注を取り出し、保存します。
 
- 114 -
 
3. Otherwise, take off the part until the first emphasised part or footnote, or until the end of the string, and store it as normal text.
4. If there is anything left in the paragraph, start at 1 again.
 
3. それ以外の場合、強調部分もしくは脚注に出会うまで、あるいは文字列の最後までを抜き出し、通常テキストとして保存します。
4. 段落内に文字列が残っている限り、1から処理を繰り返します。
 
Exercise 23
練習問題23
 
Build a function splitParagraph which, given a paragraph string, returns an array of paragraph fragments. Think of a good way to represent the fragments, they need type and content properties.
 
段落文字列を受け取り、段落パーツの配列を返す、splitParagraph関数を作ってみましょう。パーツを表現するための工夫が必要です。パーツはtypeとcontentというプロパティを持っています。
 
The method indexOf, which searches for a character or sub-string in a string and returns its position, or -1 if not found, will probably be useful in some way here.
 
ここではindexOf関数が役に立つでしょう。この関数は、文字列中から文字あるいは部分文字列を検索し、見つかった場合はその位置を、見つからなかった場合は-1を返します。
 
This is a tricky algorithm, and there are many not-quite-correct or way-too-long ways to describe it. If you run into problems, just think about it for a minute. Try to write inner functions that perform the smaller actions that make up the algorithm.
 
アルゴリズムはトリッキーですので、全く正しくない、あるいはあまりに長すぎるものになってしまうかもしれません。困難に直面したときは、立ち止まってちょっとだけ考えてみてください。アルゴリズムを補助する小さな処理を行ってくれる、内部関数を書いてみてみましょう。
 
Solution
解答
 
Here is one possible solution:
 
一つの例として参考にしてみてください。
 
splitParagraph = (text) ->
# Find character position or end of text
# 文字の位置、あるいはテキストの最後を返します
indexOrEnd = (character) ->
index = text.indexOf character
if index == -1 then text.length else index
 
# Return and remove text upto next special
# character or end of text
# 次の特殊文字あるいはテキストの最後までの文字列を返し、それを除きます
takeNormal = ->
end = reduce map(['*', '{'], indexOrEnd),
Math.min, text.length
part = text.slice 0, end
text = text.slice end
part
 
# Return and remove text upto character
# 引数の文字までを返し、取り除きます
takeUpTo = (character) ->
 
- 115 -
 
end = text.indexOf character, 1
if end == -1
throw new Error 'Missing closing ' +
'"' + character + '"'
part = text.slice 1, end
text = text.slice end + 1
part
 
fragments = [];
 
while text != ''
if text[0] == '*'
fragments.push
type: 'emphasised',
content: takeUpTo '*'
else if text[0] == '{'
fragments.push
type: 'footnote',
content: takeUpTo '}'
else
fragments.push
type: 'normal',
content: takeNormal()
fragments
 
Note the over-eager use of map and reduce in the takeNormal function This is a chapter about functional programming, so program functionally we will! Can you see how this works? The map produces an array of positions where the given characters were found, or the end of the string if they were not found, and the reduce takes the minimum of them, which is the next point in the string that we have to look at. If you’d write that out without mapping and reducing you’d get something like this: takeNormalAlternative = ->
 
takeNormal関数内で、mapとreduceが頻繁に使われていることに注目してください。この章は関数プログラミングの章であり、従って関数的なプログラミングを目指しましょう！これがどのように動くか分かりますか？　mapは与えられた文字が見つかった位置、あるいは見つからなかった場合は文字列の最終位置、これらの配列を返します。そしてreduceはそれらの中での最小値を取ります。この値が、文字列内で次に処理を開始する地点になります。mapとreduceを使わなかった場合、関数は例えば次のようになります。 takeNormalAlternative = ->
 
nextAsterisk = text.indexOf '*'
nextBrace = text.indexOf '{'
end = text.length
if nextAsterisk != -1
 
- 116 -
 
end = nextAsterisk
if nextBrace != -1 and nextBrace < end
end = nextBrace
part = text.slice 0, end
text = text.slice end
part
 
Which is even more hideous. Most of the time, when a decision has to be made based on a series of things, even if there are only two of them, writing it as array operations is nicer than handling every value in a separate if statement. (Fortunately, Regular Expressions describes an easier way to ask for the first occurrence of ‘this or that character’ in a string.)
 
このやり方だと、大変恐ろしいことになっていますね。大概の場合、複数の物事に関して決断を下す必要がある時には、たとえそれが2つだけだとしても、配列操作として扱うほうが、それぞれの値を個別のif節で扱うよりも良いコードになります。(幸いなことに正規表現では、文字列中に最初に出てくる「この文字か、あの文字」を簡単に探す方法が説明しています)
 
If you wrote a splitParagraph that stored fragments in a different way than the solution above, you might want to adjust it, because the functions in the rest of the chapter assume that fragments are objects with type and content properties.
 
もし上に挙げた解答以外の方法でパーツを保存するsplitParagraph関数を書いたのであれば、修正することをお勧めします。なぜなら、本章の残りで出てくる関数は、パーツ配列がtypeとcontentの2つのプロパティを持ったオブジェクトの配列であることを前提としているからです。
 
We can now wire processParagraph to also split the text inside the paragraphs, my version can be modified like this:
 
ここからprocessParagraphを連携させて、段落内のテキストを分割します。私の場合、このように修正しました。
 
processParagraph = (paragraph) ->
header = 0
while paragraph[0] == '%'
paragraph = paragraph.slice 1
header++
type: if header == 0 then 'p' else 'h' + header,
content: splitParagraph paragraph
# Adhoc test
# 追加テスト
recluseFile = readTextFile '06-RecluseFile.text'
paragraphs = map recluseFile.split('\n\n'),
processParagraph
show paragraphs, 3
 
Mapping that over the array of paragraphs gives us an array of paragraph objects, which in turn contain arrays of fragment objects. The next thing to do is to take out the footnotes, and put references to them in their place.
 
段落の配列に対してmap処理を行い、段落オブジェクトの配列を取得します。このオブジェクトは、内部にパーツオブジェクトの配列を持っています。次は脚注を取り出し、元の場所に参照点を追加しましょう。
 
Something like this:
 
大体このようになります。
 
extractFootnotes = (paragraphs) ->
 
- 117 -
 
footnotes = []
currentNote = 0
replaceFootnote = (fragment) ->
if fragment.type == 'footnote'
++currentNote
footnotes.push fragment
fragment.number = currentNote
type: 'reference', number: currentNote
else
fragment
forEach paragraphs, (paragraph) ->
paragraph.content = map paragraph.content,
replaceFootnote
footnotes
 
The replaceFootnote function is called on every fragment. When it gets a fragment that should stay where it is, it just returns it, but when it gets a footnote, it stores this footnote in the footnotes array, and returns a reference to it instead. In the process, every footnote and reference is also numbered.
 
全てのパーツに対してreplaceFootnote関数を適用します。移動すべきではないパーツの場合は、関数はそのままその値を返します。脚注だった場合は、その脚注を配列に保存し、脚注への参照を返します。この過程で、全ての脚注とその参照の両方に数字が割り振られることになります。
 
○●○
 
That gives us enough tools to extract the information we need from the file. All that is left now is generating the correct HTML. A lot of people think that concatenating strings is a great way to produce HTML. When they need a link to, for example, a site where you can play the game of Go, they will do:
 
これで、ファイルから必要な情報を抽出するための道具立てがそろいました。残った作業は、正しいHTMLを生成することだけです。多くの人々は、HTMLを作るには文字列の連結が最良であると考えています。例えば、囲碁をプレイできるサイトへのリンクが必要な場合は、このようにすることでしょう。
 
url = "http://www.gokgs.com/"
text = "Play Go!"
linkText = "<a href=\"#{url}\">#{text}</a>"
show linkText
 
(Where a is the tag used to create links in HTML documents.) … Not only is this clumsy, but when the string text happens to include an angular bracket or an ampersand, it is also wrong. Weird things will happen on your website, and you will look embarrassingly amateurish. We would not want that to happen. A few simple HTML-generating functions are easy to write. So let us write them.
 
(ここでaは、HTMLドキュメント内にリンクを作るためのタグを意味します)しかしこれはやり方が拙いだけでなく、文字列が山括弧やアンド記号を含んでいた場合、このタグは間違っていることになります。そうなるとウェブサイトの挙動がおかしくなるでしょうし、「このサイトの作り手はとんでもない素人だ」と判断されてしまうでしょう。そんなことは避けなければいけません。ここでシンプルなHTML生成関数をいくつか書いてみることにします。簡単な作業ですので、早速やってみましょう。
 
○●○
 
- 118 -
 
The secret to successful HTML generation is to treat your HTML document as a data structure instead of a flat piece of text. CoffeeScript’s objects provide a very easy way to model this:
 
HTML生成を成功させるための秘訣は、HTMLをフラットなテキストとしてではなく、データ構造として扱うことです。CoffeeScriptのオブジェクトを使うと、簡単にモデリングを行うことができます。
 
linkObject =
name: 'a'
attributes:
href: 'http://www.gokgs.com/'
content: ['Play Go!']
content:['囲碁をプレイ！']
 
Each HTML element contains a name property, giving the name of the tag it represents. When it has attributes, it also contains an attributes property, which contains an object in which the attributes are stored. When it has content, there is a content property, containing an array of other elements contained in this element. Strings play the role of pieces of text in our HTML document, so the array ['Play Go!'] means that this link has only one element inside it, which is a simple piece of text.
 
各々のHTML要素は、タグ名に相当するnameプロパティを持っています。タグが属性を持つ場合、HTML要素はattributesプロパティを持ち、そこには様々な属性が保存されているオブジェクトが入ります。タグに中身がある場合、要素内に含まれる他のHTML要素の配列を収めたcontentプロパティを持つことになります。String型は、HTMLドキュメント内のテキストの役割を果たします。従って配列[‘囲碁をプレイ！’]は、リンク内にはただ一つの要素、すなわちシンプルなテキストしか含まれていないことを意味します。
 
Typing in these objects directly is clumsy, but we do not have to do that. We provide a shortcut function to do this for us:
 
これらのオブジェクトを直接タイピングするのは面倒です。わざわざそうする必要はありません。ここで手間を省いてくれる関数を作りましょう：
 
tag = (name, content, attributes) ->
name: name
attributes: attributes
content: content
 
Note that, since we allow the attributes and content of an element to be undefined if they are not applicable, the second and third argument to this function can be left off when they are not needed.
 
ここで、attributes や要素のcontent などを適用しない場合、それらにundefinedをセットするものとしましょう。ですので関数の2つ目と3つ目の引数は、必要なければ空にしておけます。
 
tag is still rather primitive, so we write shortcuts for common types of elements, such as links, or the outer structure of a simple document:
 
tag関数はまだ初歩の段階です。リンクやシンプルなドキュメントの外部構造など、HTML要素の基本的な型を作るためのショートカットを用意します。
 
link = (target, text) ->
tag "a", [text], href: target
show link "http://www.gokgs.com/", "Play Go!"
show link "http://www.gokgs.com/", "囲碁をプレイ！"
htmlDoc = (title, bodyContent) ->
tag "html", [tag("head", [tag "title", [title]]),
tag "body", bodyContent]
show htmlDoc "Quote", "In his house at R'lyeh " +
"dead Cthulu waits dreaming."
show htmlDoc “引用”, “ルルイエの館にて” +
          	"死せるクトゥルフ夢見るままに待ちいたり”
 
- 119 -
 
Exercise 24
練習問題24
 
Looking back at the example HTML document if necessary, write an image function which, when given the location of an image file, will create an img HTML element.
必要であればサンプルのHTMLドキュメントの参考にし、画像ファイルの場所を与えるとimg要素を生成するimage関数を作ってください。
 
Solution
解答
 
image = (src) ->
tag 'img', [], src: src
 
When we have created a document, it will have to be reduced to a string. But building this string from the data structures we have been producing is very straightforward. The important thing is to remember to transform the special characters in the text of our document…
 
ドキュメントが完成したら、それを文字列にまで落とし込まなければいけません。これまで作ってきたデータ構造から文字列を組み立てるのは、非常にシンプルなやり方でできます。ここで重要なのは、ドキュメントのテキスト部分の特殊文字を変形処理することです。
 
escapeHTML = (text) ->
replacements = [[/&/g, '&amp;']
[/"/g, '&quot;']
[/</g, '&lt;']
[/>/g, '&gt;']]
forEach replacements, (replace) ->
text = text.replace replace[0], replace[1]
text
 
The replace method of strings creates a new string in which all occurrences of the pattern in the first argument are replaced by the second argument, so 'Borobudur'.replace(/r/g, 'k') gives 'Bokobuduk'. Do not worry about the pattern syntax here - we will get to that in Regular Expressions.
 
文字列が持つreplace関数は、1番目の引数で与えられた正規表現パターンを全て2番目の引数で置換し、新しい文字列として返します。つまり‘Borobudur’.replace(/r/g, ‘k’)は'Bokobuduk’を返します。パターンのシンタクスについては正規表現で説明しますので、今は気にしないで下さい。
 
The escapeHTML function puts the different replacements that have to be made into an array, so that it can loop over them and apply them to the argument one by one.
 
escapeHTMLでは複数の置換を行いますので、それらを配列として用意し、引数に対して一つ一つループで適用してゆくことになります。
 
Double quotes are also replaced, because we will also be using this function for the text inside the attributes of HTML tags. Those will be surrounded by double quotes, and thus must not have any double quotes inside of them.
 
ダブルクォーテーションも置換します。なぜならHTMLタグの属性部分のテキストにもこの関数を使うからです。属性はダブルクォーテーションで囲みます。従ってその中にダブルクォーテーションを含んではいけないのです。
 
Calling replace four times means the computer has to go over the whole string four times to check and replace its content. This is not very efficient.
 
replace関数を4回呼ぶことは、コンピュータが文字列全体を4回チェックし、その内容を置換しなければいけないことを意味します。これはあまり効率的ではありませんよね。
 
- 120 -
 
cient. If we cared enough, we could write a more complex version of this function, something that resembles the splitParagraph function we saw earlier, to go over it only once. For now, we are too lazy for this. Again, Regular Expressions shows a much better way to do this.
 
注意してみると、この関数をもっと複雑にしたものを作ることができそうです。先ほどsplitParagraph 関数で見たように、一度だけの実行で済ませてしまおうというわけです。ただ、面倒ですので今はこの作業は行いません。ここで再び正規表現を使って、さらにベターな方法を実現してみましょう。
 
○●○
 
To turn an HTML element object into a string, we can use a recursive function like this:
 
HTML要素を文字列に変換するには、このように再帰関数を使うことができます。
 
renderHTML = (element) ->
pieces = []
renderAttributes = (attributes) ->
result = []
if attributes
for name of attributes
result.push ' ' + name + '="' +
escapeHTML(attributes[name]) + '"'
result.join ''
 
render = (element) ->
# Text node
# テキストノード
if typeof element is 'string'
pieces.push escapeHTML element
# Empty tag
# 空のタグ
else if not element.content or
element.content.length == 0
pieces.push '<' + element.name +
renderAttributes(element.attributes) + '/>'
# Tag with content
# 内容のあるタグ
else
pieces.push '<' + element.name +
renderAttributes(element.attributes) + '>'
forEach element.content, render
pieces.push '</' + element.name + '>'
 
render element
pieces.join ''
 
Note the of loop that extracts the properties from a CoffeeScript object in order to make HTML tag attributes out of them. Also note that in two
 
CoffeeScriptオブジェクトからプロパティを抽出しているofループに注目してください。ここでHTMLタグに属性を追加しています。
 
- 121 -
 
Also note that in two places, arrays are being used to accumulate strings, which are then joined into a single result string. Why did I not just start with an empty string and then add the content to it with the += operator?
 
また、文字列を貯めるのに使われている配列が2箇所あります。
それぞれ配列の中身が結合され、一つの文字列になるのです。空の文字列に、内容を順次+=演算子で追加してゆくというシンプルな方法を採らないのは何故でしょうか？
 
It turns out that creating new strings, especially big strings, is quite a lot of work. Remember that CoffeeScript string values never change. If you concatenate something to them, a new string is created, the old ones stay intact. If we build up a big string by concatenating lots of little strings, new strings have to be created at every step, only to be thrown away when the next piece is concatenated to them. If, on the other hand, we store all the little strings in an array and then join them, only one big string has to be created.
 
それは新しい文字列－特に大きな文字列－を生成するのは、とてもコストのかかる作業だからです。CoffeeScriptでは、文字列が決して変化しないということを思い出してください。文字列に何かを連結させる際、そこでは新しい文字列が生成され、元の文字列はそっくりそのまま残っているのです。小さな文字列を沢山連結して大きな文字列を作ろうとすれば、その連結過程で、次の文字列を連結するためだけにその都度新しい文字列が生成されてしまいます。逆に小さな文字列を全て配列の中に収めて、それらをjoinするという方法であれば、一つの大きな文字列を生成するだけで済むのです。
 
○●○
 
So, let us try out this HTML generating system…
 
さあ、HTML生成システムを実際に動かしてみましょう。
 
show renderHTML link 'http://www.nedroid.com',
'Drawings!'
'お絵描き！'
 
That seems to work.
 
これは問題なく動くでしょう。
 
body = [tag('h1', ['The Test']),
tag('p', ['Here is a paragraph ' +
'and an image...']),
tag('p', [‘ここに段落と’ +
‘画像が来ます…’]),
image('../img/ostrich.jpg')]
doc = htmlDoc 'The Test', body
doc = htmlDoc 'テスト', body
show renderHTML doc
# Type `stopServer()` or Ctrl-C when done.
# `stopServer()` とタイプするかCtrl-Cを押して終了します。
viewServer renderHTML doc
 
Now, I should probably warn you that this approach is not perfect. What it actually renders is XML, which is similar to HTML, but more structured. In simple cases, such as the above, this does not cause any problems. However, there are some things, which are correct XML, but not proper HTML, and these might confuse a browser that is trying to show the documents we create. For example, if you have an empty script tag (used to put JavaScript into a page) in your document, browsers will not realise that it is empty and think that everything after it is JavaScript. (In this case, the problem can be fixed by putting a single space inside of the tag, so that it is no longer empty, and gets a proper closing tag.)
 
ここで、この方法が不完全なものであるということを指摘しておかなければいけません。この方法では、HTMLに似ていますがもう少し構造的なXMLというものがレンダリングされます。上で見たようなシンプルなケースでは、問題にはなりません。しかし幾つかの要素の中で、XMLとしては正しいものの適切なHTMLではないものがあり、それらが入ったドキュメントを表示させようとすると、ブラウザが正常に動作しないこともあります。例えば空のscriptタグ（ページ内にJavaScriptを入れるためのタグ）がドキュメント内にある場合、ブラウザはそれが空であると理解できず、そのタグ以降のテキストを全てJavaScriptであると判断してしまいます。（この場合、タグの中にスペースを一つ挿入すれば、それは空タグでなくなり閉じタグも正しく解釈されることで、問題は解決します。）
 
- 122 -
 
Exercise 25
練習問題25
 
Write a function renderFragment, and use that to implement another function renderParagraph, which takes a paragraph object (with the footnotes already filtered out), and produces the correct HTML element (which might be a paragraph or a header, depending on the type property of the paragraph object).
 
まずrenderFragment関数を書き、それを利用してrenderParagraph関数を実装してください。renderParagraph関数は、脚注がすでに取り除かれた段落オブジェクトを引数に取り、その段落オブジェクトのtypeプロパティに基づいて、段落やヘッダなどの正しいHTML要素を作ります。
 
This function might come in useful for rendering the footnote references:
 
脚注の参照をレンダリングする際は、この関数を使ってみてください。
 
footnote = (number) ->
tag 'sup',
[link '#footnote' + number, String number]
 
A sup tag will show its content as ‘superscript’, which means it will be smaller and a little higher than other text. The target of the link will be something like '#footnote1'. Links that contain a ‘#’ character refer to ‘anchors’ within a page, and in this case we will use them to make it so that clicking on the footnote link will take the reader to the bottom of the page, where the footnotes live.
 
supタグはその内容を「上付き(=superscript)」として表示します。つまり他のテキストよりも小さく、文字位置が少し上の部分に表示されます。リンクの参照先は「#footnote1」のようになります。「#」を含んだリンクはページ内の「アンカー」を参照し、今回の場合脚注リンクをクリックすればページの下の脚注内容が書かれている部分に飛ぶことになります。
 
The tag to render emphasised fragments with is em, and normal text can be rendered without any extra tags.
 
強調パーツにはemタグが使われ、通常のテキストは余計なタグなしでレンダリングされます。
 
Solution
解答
 
renderFragment = (fragment) ->
if fragment.type == 'reference'
footnote fragment.number
else if fragment.type == 'emphasised'
tag 'em', [fragment.content]
else if fragment.type == 'normal'
fragment.content
 
renderParagraph = (paragraph) ->
tag paragraph.type,
map paragraph.content, renderFragment
 
show renderParagraph paragraphs[7]
 
-123 -
 
We are almost finished. The only thing that we do not have a rendering function for yet are the footnotes. To make the '#footnote1' links work, an anchor must be included with every footnote. In HTML, an anchor is specified with an a element, which is also used for links. In this case, it needs a name attribute, instead of an href.
 
さあゴールはもう目の前です。レンダリング関数が必要な要素は、脚注を残すだけとなりました。「#footnote1」リンクを機能させるために、全ての脚注にアンカーを付ける必要があります。HTMLでは、アンカーはa要素で指定します。これはリンクにも使えます。アンカーにはhref要素ではなく、name要素が必要です。
 
renderFootnote = (footnote) ->
anchor = tag "a", [],
name: "footnote" + footnote.number
number = "[#{footnote.number}] "
tag "p", [tag("small",
[anchor, number, footnote.content])]
 
Here, then, is the function which, when given a file in the correct format and a document title, returns an HTML document:
 
そして次の関数は、正しくフォーマットされたファイルとドキュメントのタイトルを与えると、HTMLドキュメントを返します。
 
renderFile = (file, title) ->
paragraphs = map file.split('\n\n'),
processParagraph
footnotes = map extractFootnotes(paragraphs),
renderFootnote
body = map paragraphs,
renderParagraph
body = body.concat footnotes
renderHTML htmlDoc title, body
 
page = renderFile recluseFile, 'The Book of Programming'
show page
# Type `stopServer()` or Ctrl-C when done.
# `stopServer()` とタイプするかCtrl-Cを押して終了します。
viewServer page
 
The concat method of an array can be used to concatenate another array to it, similar to what the + operator does with strings.
 
配列はconcatメソッドで、他の配列をつなげることができます。文字列に対して＋演算を行うのと同じですね。
 
○●○
 
In the chapters after this one, elementary higher-order functions like map and reduce will always be available from the Underscore library and will be used by code examples. Now and then, a new useful tool is explained and added to this. In Modularity, we develop a more structured approach to this set of ‘basic’ functions.
 
以降の章では、基礎的な高階関数として、Underscoreライブラリに収められているmapおよびreduce関数をコードサンプルで頻繁に使うことになります。この他にも、便利なツールを適宜紹介し説明・使用してゆくことになります。モジュール性では、これらの「ベーシックな」関数に対して、より構造的なアプローチで迫ってゆきます。
 
○●○
 
 
- 124 -
 
In some functional programming languages operators are functions, for example in Pure you can write foldl (+) 0 (1..10); the same in CoffeeScript is reduce [1..10], ((a, b) -> a + b), 0.
 
Pureなどの幾つかの関数型プログラミング言語では、foldl (+) 0 (1..10)のように書くことができます。CoffeeScriptでは同じ処理をreduce [1..10], ((a, b) -> a + b), 0と書きます。
 
A way to shorten this is by defining an object that is indexed by an operator in a string:
 
これをコンパクトに書くには、演算子を文字列で表現し、それをインデックスとしたオブジェクトを定義するというやり方があります。
 
op = {
'+': (a, b) -> a + b
'==': (a, b) -> a == b
'!': (a) -> !a
# and so on
}
show reduce [1..10], op['+'], 0
 
The list of operators is quite long, so it is questionable whether such a data structure improves readability compared to:
 
しかしこれでは演算子のリストは膨大な量になります。このようなデータ構造が、果たして可読性の向上につながるかどうかは疑問です。逆に次のように書いてみるのはどうでしょうか。
 
add = (a, b) -> a + b
show reduce [1..10], add, 0
 
And what if we need something like equals or makeAddFunction, in which one of the arguments already has a value? In that case we are back to writing a new function again.
 
更に、引数の一方がすでに値を持っているようなequalsやmakdAddFunctionのような関数を作りたい場合はどうでしょう？このような場合には、改めて新しい関数を作ってみましょう。
 
For cases like that, something called ‘partial application’ is useful. You want to create a new function that already knows some of its arguments, and treats any additional arguments it is passed as coming after these fixed arguments. A simple version of this could be:
 
ここで「部分適用」という概念が役に立ちます。引数の幾つかの値がすでに分かっており、それらの固定引数に続けて他の引数を渡す、そういった関数を新しく作ってみましょう。単純に書いてしまえば次のようになるはずです。
 
partial = (func, a...) ->
(b...) -> func a..., b...
 
f = (a,b,c,d) -> show "#{a} #{b} #{c} #{d}"
g = partial f, 1, 2
g 3, 4
 
The return value of partial is a function where the a... arguments have been applied. When the returned function is called the b... arguments are appended to the arguments of func.
 
partialの戻り値は、引数「a…」が適用済みの関数となります。こうして得られた関数は「b…」を引数に与えると実行できますが、この引数は実際にはfuncの引数リストに追加されることになります。
 
equals10 = partial op['=='], 10
show map [1, 10, 100], equals10
 
Unlike traditional functional definitions, Underscore defines the order of its arguments as array before action. That means we can not simply say:
 
伝統的な関数定義と異なり、Underscoreでは関数の実行前に引数の順序を配列として定義します。従って次のように単純に書くことはできません。
 
- 125 -
 
square = (x) -> x * x
show map [[10, 100], [12, 16], [0, 1]],
partial map, square # Incorrect

partial map, square # 正しくありません
 
Since the square function needs to be the second argument of the inner map. But we can define another partial function that reverses its arguments:
 
何故ならsquare関数は、内側にあるmapの2番目の引数である必要があるからです。ですので、ここで引数の順序を逆にするpartial関数をもう一つ作ってみましょう。
 
partialReverse = (func, a) -> (b) -> func b, a
 
mapSquared = partialReverse map, square
show map [[10, 100], [12, 16], [0, 1]], mapSquared
 
However it is again worthwhile to consider whether the intent of the program is clearer when the functions are defined directly:
 
しかしここでも、プログラムの意図が、関数を直接定義した時よりも明瞭になっているのかどうかを十分に考慮する必要があります。
 
show map [[10, 100], [12, 16], [0, 1]],
(sublist) -> map sublist, (x) -> x * x
 
○●○
 
A trick that can be useful when you want to combine functions is function composition. At the start of this chapter I showed a function negate, which applies the boolean not operator to the result of calling a function:
 
関数を繋げたいときは、関数合成を行うことをお勧めします。この章の始めに、negate関数を紹介しました。これはboolean型のnot演算子を関数の呼び出し結果に適用するものです。
 
negate = (func) ->
(args...) -> not func args...
 
This is a special case of a general pattern: call function A, and then apply function B to the result. Composition is a common concept in mathematics. It can be caught in a higher-order function like this:
 
関数Aを呼び出し、その結果に関数Bを適用するという、一般的なパターンの特殊例となります。合成は数学上の共通概念です。高階関数において、合成は次のように実現できます。
 
compose = (func1, func2) ->
(args...) -> func1 func2 args...
 
isUndefined = (value) -> value is undefined
isDefined = compose ((v) -> not v), isUndefined
show 'isDefined Math.PI = ' + isDefined Math.PI
show 'isDefined Math.PIE = ' + isDefined Math.PIE
 
In isDefined we are defining a new function without naming it. This can be useful when you need to create a simple function to give to, for example, map or reduce. However, when a function becomes more complex than this example, it is usually shorter and clearer to define it by itself and name it.
 
isDefined関数では、名前を付けることなく新しい関数を定義しています。これは、mapやreduceなどに渡す簡単な関数を作りたい時に使う手法です。ただし、関数がこの例よりも複雑になってきた場合には、関数にきちんと定義して名前を付けてやったほうが、コードはより短くそして簡潔になります。
 
